import{Input as e}from"@milque/input";import{GameLoop as t}from"@milque/game";import{DisplayPort as n,View as i}from"@milque/display";import{Eventable as r}from"@milque/util";const o=e.createContext().disable(),s=o.registerRange("x","mouse[pos].x"),a=o.registerRange("y","mouse[pos].y"),l=o.registerState("ldown",{"mouse[0].up":0,"mouse[0].down":1}),d=o.registerState("rdown",{"mouse[2].up":0,"mouse[2].down":1}),u=o.registerAction("click","mouse.up"),p=o.registerAction("lclick","mouse[0].up"),c=o.registerAction("rclick","mouse[2].up");var h=Object.freeze({__proto__:null,CONTEXT:o,POS_X:s,POS_Y:a,LEFT_DOWN:l,RIGHT_DOWN:d,CLICK:u,LEFT_CLICK:p,RIGHT_CLICK:c});const m=e.createContext().disable(),f=m.registerState("up",{"key[ArrowUp].up":0,"key[ArrowUp].down":1,"key[w].up":0,"key[w].down":1}),w=m.registerState("down",{"key[ArrowDown].up":0,"key[ArrowDown].down":1,"key[s].up":0,"key[s].down":1}),y=m.registerState("left",{"key[ArrowLeft].up":0,"key[ArrowLeft].down":1,"key[a].up":0,"key[a].down":1}),g=m.registerState("right",{"key[ArrowRight].up":0,"key[ArrowRight].down":1,"key[d].up":0,"key[d].down":1});var x=Object.freeze({__proto__:null,CONTEXT:m,UP:f,DOWN:w,LEFT:y,RIGHT:g});const _=Symbol("gameInfo");async function S(e){e||(e={});let r=document.querySelector("display-port");r||(r=new n,r.toggleAttribute("full"),r.toggleAttribute("debug"),document.body.appendChild(r));let o=e.load&&await e.load(e)||Object.isExtensible(e)&&e||{},s=o.view||i.createView(),a=o.viewport||{x:0,y:0,get width(){return r.getCanvas().clientWidth},get height(){return r.getCanvas().clientHeight}},l=new t,d={game:e,view:s,viewport:a,display:r,loop:l,fixed:{time:0,step:o.fixedStep||.016667},onframe:C.bind(void 0,o),onupdate:b.bind(void 0,o),onfirstupdate:v.bind(void 0,o)};return Object.defineProperty(o,_,{value:d,enumerable:!1,configurable:!0}),l.addEventListener("update",d.onfirstupdate,{once:!0}),l.start(),o}function v(e,t){let{display:n,loop:i,onupdate:r,onframe:o}=e[_];console.log("FIRST"),game.start&&game.start.call(e),r.call(e,t),i.addEventListener("update",r),n.addEventListener("frame",o)}function b(e,t){let{game:n,fixed:i}=e[_],r=t.detail.delta;if(n.preupdate&&n.preupdate.call(e,r),n.update&&n.update.call(e,r),n.fixedupdate){let t=i.step,o=250*t;for(i.time>o?i.time=o:i.time+=r;i.time>=t;)i.time-=t,n.fixedupdate.call(e)}n.postupdate&&n.postupdate.call(e,r)}function C(e,t){let{game:n,display:i,view:r,viewport:o}=e[_],s=t.detail.context;r.context.setTransform(1,0,0,1,0,0),r.context.clearRect(0,0,r.width,r.height),n.render&&n.render.call(e,r,e),i.clear("black"),r.drawBufferToCanvas(s,o.x,o.y,o.width,o.height)}async function k(e){let{game:t,onframe:n,onupdate:i,onfirstupdate:r}=e[_];return t.loop.removeEventListener("update",r),t.loop.removeEventListener("update",i),t.display.removeEventListener("frame",n),await new Promise(n=>{t.loop.addEventListener("stop",async()=>{t.stop&&t.stop(),t.unload&&await t.unload(e),n(e)},{once:!0}),t.loop.stop()})}var T=Object.freeze({__proto__:null,startGame:S,pauseGame:async function(e){let{loop:t}=e[_];t.pause()},resumeGame:async function(e){let{loop:t}=e[_];t.resume()},stopGame:k,nextGame:async function(e,t){return await k(e),await S(t)}});const L=e.createContext().disable(),E=L.registerAction("continue","key.down","mouse.down");class O{constructor(e,t){this.splashText=e,this.nextScene=t}async load(e){L.enable()}async unload(e){L.disable()}onStart(){this.time=0}onUpdate(e){this.time+=e,E.value&&this.time>75&&this.time<225&&(this.time=225),this.time>250&&(void 0)(this.nextScene)}onRender(e,t,n){let i=0;i=n.time<75?n.time/75:n.time>225?(250-n.time)/25:1,function(e,t,n,i,r=0,o=16,s="white"){e.translate(n,i),r&&e.rotate(r),e.textAlign="center",e.textBaseline="middle",e.font=`${o}px sans-serif`,e.fillStyle=s,e.fillText(t,0,0),r&&e.rotate(-r),e.translate(-n,-i)}(e,this.splashText,t.width/2,t.height/2,0,16,`rgba(255, 255, 255, ${i})`)}}var A=Object.freeze({__proto__:null,createSpawner:function(e){return{entities:new Set,factory:e,create(...e){return this.factory.apply(null,e)},destroy(e){this.entities.delete(e)},spawn(...e){let t=this.create(...e);return this.entities.add(t),t},clear(){this.entities.clear()},[Symbol.iterator](){return this.entities.values()}}}});const U={};class P{constructor(){this.registry=new Map,this.sharedContext={},this._scene=null,this._nextScene=null,this._nextLoadOpts=null,this._nextTransition=null}setSharedContext(e){return this.sharedContext=e,this}register(e,t){if("string"!=typeof e)throw new Error("Scene name must be a string.");return this.registry.set(e,t),this}unregister(e){return this.registry.delete(e),this}nextScene(e,t=null,n={}){if(this._nextScene)throw new Error("Cannot change scenes during a scene transition.");if("string"==typeof e){if(!this.registry.has(e))throw new Error(`Cannot find scene with name '${e}'.`);e=this.registry.get(e)}if("function"==typeof e)e=new e;else{if("object"!=typeof e)throw new Error("Scene type not supported.");Object.isExtensible(e)||(i=e,e={...i})}var i;this._nextScene=e,this._nextLoadOpts=n,this._nextTransition=t||U}update(e){if(this._transition)this._updateStep(e,this._transition);else if(this._nextScene){const e=this._nextScene,t=this._nextLoadOpts,n=this._nextTransition;this._nextScene=null,this._nextLoadOpts=null,this._nextTransition=null,this._transition=n;let i=Promise.resolve(),r=this._scene;r&&("onStop"in r&&r.onStop(this.sharedContext),"unload"in r&&(i=i.then(()=>r.unload(this.sharedContext)))),"load"in e&&(i=i.then(()=>e.load(this.sharedContext,t))),i=i.then(()=>{this._scene=e,this._transition=null,"onStart"in this._scene&&this._scene.onStart(this.sharedContext)})}else this._scene&&this._updateStep(e,this._scene)}_updateStep(e,t){"onPreUpdate"in t&&t.onPreUpdate(e),this.emit("preupdate",e),"onUpdate"in t&&t.onUpdate(e),this.emit("update",e),"onPostUpdate"in t&&t.onPostUpdate(e),this.emit("postupdate",e)}getCurrentScene(){return this._scene}getNextScene(){return this._nextScene}[Symbol.iterator](){return this.registry[Symbol.iterator]()}}r.mixin(P);class R{async load(e,t){}async unload(e){}onStart(e){}onStop(e){}onPreUpdate(e){}onUpdate(e){}onPostUpdate(e){}}export{A as EntitySpawner,T as Game,h as MouseControls,x as MoveControls,R as SceneBase,P as SceneManager,O as SplashScene};
