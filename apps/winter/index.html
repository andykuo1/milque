<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">

        <title>Winter</title>

        <script type="module" src="../../packages/display/src/index.js"></script>
    </head>
    <body>
        <display-port contexttype="2d"></display-port>

        <script type="module">
            import { KeyMapBuilder, createKeyState, createDeviceMap } from './InputHelper.js';
            import * as Intersection from './IntersectionHelper.js';

            window.addEventListener('DOMContentLoaded', () => {
                const display = document.querySelector('display-port');
                
                // This is what the user sees and can edit.
                const keyMap = KeyMapBuilder()
                    .set('up', 'ArrowUp')
                    .set('down', 'ArrowDown')
                    .set('left', 'ArrowLeft')
                    .set('right', 'ArrowRight')
                    .build();
                const deviceMap = createDeviceMap(display);
                const keyState = createKeyState(deviceMap, keyMap);

                // input.getContextualInputState('playerControls');
                // Easy to access, fast, and serializable
                const playerControls = {
                    get down() { return keyState.state.down.value; },
                    get up() { return keyState.state.up.value; },
                    get left() { return keyState.state.left.value; },
                    get right() { return keyState.state.right.value; },
                };

                const world = {
                    entities: [],
                    update(dt)
                    {
                        for(let entity of this.entities)
                        {
                            entity.update(dt);
                        }
                    },
                    render(ctx)
                    {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);

                        for(let entity of this.entities)
                        {
                            entity.render(ctx);
                        }
                    },
                    poll()
                    {
                        keyState.poll();
                    }
                };

                display.addEventListener('frame', e => {
                    const ctx = e.detail.context;
                    const dt = e.detail.delta;

                    if (world.poll) world.poll();
                    if (world.update) world.update(dt);

                    // Move to first quadrant.
                    ctx.setTransform(1, 0, 0, -1, 0, 0);
                    ctx.translate(0, -ctx.canvas.clientHeight);
                    if (world.render) world.render(ctx);
                });

                main();

                function main()
                {
                    world.entities = [
                        Player()
                    ];
                }

                function Platform()
                {
                    return {
                        type: 'platform',
                        x: 0,
                        y: 0,
                        width: 64,
                        height: 4,
                        render(ctx)
                        {

                        }
                    }
                }

                function Player()
                {
                    return {
                        x: 0,
                        y: 0,
                        dx: 0,
                        dy: 0,
                        jumping: false,
                        update(dt)
                        {
                            const moveSpeed = 0.3;
                            const moveFriction = 1 - 0.1;
                            const jumpSpeed = 8;
                            const jumpMoveFriction = 1 - 0.08;
                            const gravitySpeed = 0.5;

                            const onGround = this.y <= 0;

                            if (!onGround) {
                                this.dy -= gravitySpeed;
                            } else if (playerControls.up) {
                                this.dy += jumpSpeed;
                            } else {
                                this.dy = 0;
                                this.y = 0;
                            }

                            if (playerControls.left) {
                                this.dx -= moveSpeed;
                            }
                            if (playerControls.right) {
                                this.dx += moveSpeed;
                            }
                            
                            this.dx *= onGround ? moveFriction : jumpMoveFriction;

                            this.x += this.dx;
                            this.y += this.dy;
                        },
                        render(ctx)
                        {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(this.x, this.y, 16, 16);
                        }
                    };
                }
            });
        </script>
    </body>
</html>