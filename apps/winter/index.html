<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">

        <title>Winter</title>

        <style>
            html, body {
                margin: 0;
            }
        </style>

        <script type="module" src="../../packages/display/src/index.js"></script>

        <script type="module" src="./IntersectionTests.js"></script>
    </head>
    <body>
        <display-port mode="fit" contexttype="2d" full debug></display-port>

        <script type="module">
            import { KeyMapBuilder, createKeyState } from './InputHelper.js';
            import * as Intersection from './IntersectionHelper.js';
            import { createIntersectionWorld } from './IntersectionWorld.js';

            window.addEventListener('DOMContentLoaded', () => {
                const display = document.querySelector('display-port');
                
                // This is what the user sees and can edit.
                const keyMap = KeyMapBuilder()
                    .set('up', 'ArrowUp')
                    .set('down', 'ArrowDown')
                    .set('left', 'ArrowLeft')
                    .set('right', 'ArrowRight')
                    .build();
                const keyState = createKeyState(display, keyMap);

                // input.getContextualInputState('playerControls');
                // Easy to access, fast, and serializable
                const playerControls = {
                    get down() { return keyState.state.down.value; },
                    get up() { return keyState.state.up.value; },
                    get left() { return keyState.state.left.value; },
                    get right() { return keyState.state.right.value; },
                };

                const world = {
                    entities: [],
                    update(dt)
                    {
                        for(let entity of this.entities)
                        {
                            entity.update(dt);
                        }
                    },
                    render(ctx)
                    {
                        for(let entity of this.entities)
                        {
                            entity.render(ctx);
                        }
                    },
                    poll()
                    {
                        keyState.poll();
                    }
                };

                display.addEventListener('frame', e => {
                    const ctx = e.detail.canvasContext;
                    const dt = e.detail.deltaTime / 60;

                    if (world.poll) world.poll();
                    if (world.update) world.update(dt);

                    // Transform canvas to first quadrant; (0,0) = bottom left, (width, height) = top right.
                    ctx.setTransform(1, 0, 0, -1, 0, 0);
                    ctx.translate(0, -display.height);

                    // Paint it black.
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, display.width, display.height);

                    if (world.render) world.render(ctx);

                    if (world.physics)
                    {
                        world.physics.update(dt);
                        world.physics.render(ctx);
                    }
                });

                main();

                function main()
                {
                    let player = Player();
                    world.entities = [
                        player
                    ];

                    let physics = createIntersectionWorld();
                    physics.dynamics.push(player.masks.aabb);
                    physics.masks.push(...[
                        player.masks.ground,
                        player.masks.motion,
                    ]);
                    physics.statics.push(...[
                        Intersection.createRect(50, 0, 150, 16),
                        Intersection.createRect(0, 0, 10, display.height),
                        Intersection.createRect(0, 0, display.width, 10),
                        Intersection.createRect(display.width - 10, 0, display.width, display.height),
                        Intersection.createRect(0, display.height - 10, display.width, display.height),
                    ]);
                    world.physics = physics;
                }

                function Player()
                {
                    let player = {
                        x: 100,
                        y: 100,
                        dx: 0,
                        dy: 0,
                        motionX: 0,
                        motionY: 0,
                        jumping: false,
                        masks: {
                            aabb: {
                                get x() { return player.x; },
                                get y() { return player.y; },
                                set x(x) { player.x = x; },
                                set y(y) { player.y = y; },
                                rx: 8,
                                ry: 8,

                                get dx() { return player.dx; },
                                get dy() { return player.dy; },
                                set dx(dx) { player.dx = dx; },
                                set dy(dy) { player.dy = dy; },
                                hit: null,
                            },
                            motion: {
                                type: 'segment',
                                get x() { return player.masks.aabb.x; },
                                get y() { return player.masks.aabb.y; },
                                get dx() { return player.motionX; },
                                get dy() { return player.motionY; },
                                px: 0,
                                py: 0,
                                
                                hit: null,
                            },
                            ground: {
                                type: 'segment',
                                get x() { return player.masks.aabb.x - player.masks.aabb.rx; },
                                get y() { return player.masks.aabb.y - player.masks.aabb.ry - 0.1; },
                                get dx() { return player.masks.aabb.rx * 2; },
                                get dy() { return 0; },
                                px: 0,
                                py: 0,
                                
                                hit: null,
                            },
                        },
                        update(dt)
                        {
                            const moveSpeed = 10;
                            const moveFriction = 1 - 0.2;
                            const jumpSpeed = 30;
                            const jumpMoveFriction = 1 - 0.08;
                            const gravitySpeed = 2;

                            const hit = this.masks.aabb.hit;
                            const hitGround = this.masks.ground.hit;

                            if (hitGround && this.motionY < 0) {
                                this.motionY = 0;
                            } else {
                                this.motionY -= gravitySpeed;
                            }

                            if (hitGround && playerControls.up) {
                                this.motionY = jumpSpeed;
                            }

                            if (playerControls.left) {
                                this.motionX = -moveSpeed;
                            }
                            if (playerControls.right) {
                                this.motionX = moveSpeed;
                            }
                            
                            this.motionX *= hitGround ? moveFriction : jumpMoveFriction;

                            this.dx += this.motionX;
                            this.dy += this.motionY;

                            // Never fall off
                            if (this.y <= 0) this.y = 0;
                        },
                        render(ctx)
                        {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(this.x - 8, this.y - 8, 16, 16);
                        }
                    };
                    return player;
                }
            });
        </script>
    </body>
</html>