<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">

        <title>Winter</title>

        <style>
            html, body {
                margin: 0;
            }
        </style>

        <script type="module" src="../../packages/display/src/index.js"></script>

        <script type="module" src="./IntersectionTests.js"></script>
    </head>
    <body>
        <display-port mode="fit" contexttype="2d" full debug></display-port>

        <script type="module">
            import { KeyMapBuilder, createKeyState } from './InputHelper.js';
            import * as Intersection from './IntersectionHelper.js';

            window.addEventListener('DOMContentLoaded', () => {
                const display = document.querySelector('display-port');
                
                // This is what the user sees and can edit.
                const keyMap = KeyMapBuilder()
                    .set('up', 'ArrowUp')
                    .set('down', 'ArrowDown')
                    .set('left', 'ArrowLeft')
                    .set('right', 'ArrowRight')
                    .build();
                const keyState = createKeyState(display, keyMap);

                // input.getContextualInputState('playerControls');
                // Easy to access, fast, and serializable
                const playerControls = {
                    get down() { return keyState.state.down.value; },
                    get up() { return keyState.state.up.value; },
                    get left() { return keyState.state.left.value; },
                    get right() { return keyState.state.right.value; },
                };

                const world = {
                    entities: [],
                    update(dt)
                    {
                        for(let entity of this.entities)
                        {
                            entity.update(dt);
                        }
                    },
                    render(ctx)
                    {
                        for(let entity of this.entities)
                        {
                            entity.render(ctx);
                        }
                    },
                    poll()
                    {
                        keyState.poll();
                    }
                };

                display.addEventListener('frame', e => {
                    const ctx = e.detail.canvasContext;
                    const dt = e.detail.deltaTime;

                    if (world.poll) world.poll();
                    if (world.update) world.update(dt);

                    // Move to first quadrant.
                    ctx.setTransform(1, 0, 0, -1, 0, 0);
                    ctx.translate(0, -display.height);

                    // Paint it black.
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, display.width, display.height);

                    if (world.render) world.render(ctx);

                    // world.physics.update(dt);
                    world.physics.draw(ctx);
                });

                main();

                function main()
                {
                    let player = Player();
                    world.entities = [
                        player
                    ];

                    world.physics = {
                        dynamicColliders: [
                            player.masks.aabb,
                        ],
                        maskColliders: [
                            player.masks.ground,
                        ],
                        staticColliders: [
                            Intersection.createRect(50, 0, 150, 16),
                            Intersection.createRect(0, 0, 10, display.height),
                            Intersection.createRect(0, 0, display.width, 10),
                            Intersection.createRect(display.width - 10, 0, display.width, display.height),
                            Intersection.createRect(0, display.height - 10, display.width, display.height),
                        ],
                        update(dt)
                        {
                            let obj = {};
                            for(let dynamicCollider of this.dynamicColliders)
                            {
                                let sweep = Intersection.sweepInto(
                                    obj,
                                    dynamicCollider,
                                    this.staticColliders,
                                    dynamicCollider.dx || 0,
                                    dynamicCollider.dy || 0);

                                dynamicCollider.hit = sweep.hit;
                                dynamicCollider.x = sweep.x;
                                dynamicCollider.y = sweep.y;
                            }

                            for(let maskCollider of this.maskColliders)
                            {
                                let obj = {};
                                let hit = null;
                                switch(maskCollider.type)
                                {
                                    case 'point':
                                        for(let staticCollider of this.staticColliders)
                                        {
                                            if (Intersection.intersectPoint(obj, staticCollider, maskCollider.x, maskCollider.y))
                                            {
                                                hit = obj;
                                                break;
                                            }
                                        }
                                        break;
                                    case 'segment':
                                        for(let staticCollider of this.staticColliders)
                                        {
                                            if (Intersection.intersectSegment(obj, staticCollider, maskCollider.x, maskCollider.y, maskCollider.dx, maskCollider.dy))
                                            {
                                                hit = obj;
                                                break;
                                            }
                                        }
                                        break;

                                }
                                maskCollider.hit = hit;
                            }
                        },
                        draw(ctx)
                        {
                            ctx.strokeStyle = 'lime';
                            for(let dynamicCollider of this.dynamicColliders)
                            {
                                ctx.strokeRect(dynamicCollider.x - dynamicCollider.rx, dynamicCollider.y - dynamicCollider.ry, dynamicCollider.rx * 2, dynamicCollider.ry * 2);
                            }
                            ctx.strokeStyle = 'blue';
                            for(let maskCollider of this.maskColliders)
                            {
                                switch(maskCollider.type)
                                {
                                    case 'point':
                                        ctx.strokeRect(maskCollider.x - 1, maskCollider.y - 1, 2, 2);
                                        break;
                                    case 'segment':
                                        ctx.beginPath();
                                        ctx.moveTo(maskCollider.x, maskCollider.y);
                                        ctx.lineTo(maskCollider.x + maskCollider.dx, maskCollider.y + maskCollider.dy);
                                        ctx.stroke();
                                        break;
                                }
                            }
                            ctx.strokeStyle = 'green';
                            for(let staticCollider of this.staticColliders)
                            {
                                ctx.strokeRect(staticCollider.x - staticCollider.rx, staticCollider.y - staticCollider.ry, staticCollider.rx * 2, staticCollider.ry * 2);
                            }
                        }
                    };
                }

                function Player()
                {
                    let player = {
                        x: 100,
                        y: 100,
                        dx: 0,
                        dy: 0,
                        jumping: false,
                        masks: {
                            aabb: {
                                get x() { return player.x; },
                                get y() { return player.y; },
                                set x(x) { player.x = x; },
                                set y(y) { player.y = y; },
                                rx: 8,
                                ry: 8,

                                get dx() { return player.dx; },
                                get dy() { return player.dy; },
                                hit: null,
                            },
                            ground: {
                                type: 'segment',
                                get x() { return player.masks.aabb.x - player.masks.aabb.rx + 0.1; },
                                get y() { return player.masks.aabb.y - player.masks.aabb.ry - 0.1; },
                                get dx() { return player.masks.aabb.rx * 2 - 0.2; },
                                get dy() { return 0; },
                                hit: null,
                            },
                        },
                        update(dt)
                        {
                            const moveSpeed = 0.3;
                            const moveFriction = 1 - 0.1;
                            const jumpSpeed = 8;
                            const jumpMoveFriction = 1 - 0.08;
                            const gravitySpeed = 0.5;

                            const hit = this.masks.aabb.hit;
                            const hitGround = this.masks.ground.hit;

                            if (!hitGround) {
                                this.dy -= gravitySpeed;
                            } else if (playerControls.up) {
                                this.dy += jumpSpeed;
                            }

                            const onGround = this.y <= 0 || hitGround;

                            if (playerControls.left) {
                                this.dx -= moveSpeed;
                            }
                            if (playerControls.right) {
                                this.dx += moveSpeed;
                            }
                            
                            this.dx *= hitGround ? moveFriction : jumpMoveFriction;

                            // Never fall off
                            if (this.y <= 0) this.y = 0;
                        },
                        render(ctx)
                        {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(this.x - 8, this.y - 8, 16, 16);
                        }
                    };
                    return player;
                }
            });
        </script>
    </body>
</html>