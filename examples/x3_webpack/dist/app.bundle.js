/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/milque.js":
/*!***********************!*\
  !*** ./lib/milque.js ***!
  \***********************/
/*! exports provided: default, AbstractCamera, AbstractInputAdapter, ActionInputAdapter, Audio, Component, ComponentBase, ComponentFactory, DOUBLE_ACTION_TIME, Display, DisplayPort, DoubleActionInputAdapter, Entity, EntityBase, EntityComponent, EntityManager, EntityQuery, EntityWrapper, EventKey, Eventable, FineDiffStrategy, Game, GameLoop, HotEntityModule, HotEntityReplacement, HybridEntity, Input, Keyboard, MAX_CONTEXT_PRIORITY, MIN_CONTEXT_PRIORITY, MODE_CENTER, MODE_FIT, MODE_NOSCALE, MODE_STRETCH, Mouse, QueryOperator, Random, RandomGenerator, RangeInputAdapter, SceneBase, SceneManager, SimpleRandomGenerator, StateInputAdapter, TagComponent, Utils, View, ViewHelper, ViewPort, createContext, createSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractCamera\", function() { return AbstractCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractInputAdapter\", function() { return AbstractInputAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActionInputAdapter\", function() { return ActionInputAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Audio\", function() { return Audio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return ComponentHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentBase\", function() { return ComponentBase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentFactory\", function() { return ComponentFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOUBLE_ACTION_TIME\", function() { return DOUBLE_ACTION_TIME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Display\", function() { return Display; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DisplayPort\", function() { return DisplayPort; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoubleActionInputAdapter\", function() { return DoubleActionInputAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return EntityHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityBase\", function() { return EntityBase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityComponent\", function() { return EntityComponent$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityManager\", function() { return EntityManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityQuery\", function() { return EntityQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityWrapper\", function() { return EntityWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventKey\", function() { return EventKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Eventable\", function() { return Eventable$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FineDiffStrategy\", function() { return FineDiffStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return Game; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GameLoop\", function() { return GameLoop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HotEntityModule\", function() { return HotEntityModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HotEntityReplacement\", function() { return HotEntityReplacement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HybridEntity\", function() { return HybridEntity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Input\", function() { return Input; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Keyboard\", function() { return Keyboard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_CONTEXT_PRIORITY\", function() { return MAX_CONTEXT_PRIORITY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MIN_CONTEXT_PRIORITY\", function() { return MIN_CONTEXT_PRIORITY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODE_CENTER\", function() { return MODE_CENTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODE_FIT\", function() { return MODE_FIT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODE_NOSCALE\", function() { return MODE_NOSCALE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODE_STRETCH\", function() { return MODE_STRETCH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mouse\", function() { return Mouse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QueryOperator\", function() { return QueryOperator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Random\", function() { return Random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RandomGenerator\", function() { return RandomGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeInputAdapter\", function() { return RangeInputAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SceneBase\", function() { return SceneBase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SceneManager\", function() { return SceneManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleRandomGenerator\", function() { return SimpleRandomGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateInputAdapter\", function() { return StateInputAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TagComponent\", function() { return TagComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewHelper\", function() { return ViewHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewPort\", function() { return ViewPort; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return createContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createSource\", function() { return createSource; });\nvar self = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get Display () { return Display; },\n    get Audio () { return Audio; },\n    get Input () { return Input; },\n    get Random () { return Random; },\n    get Utils () { return Utils; },\n    get Game () { return Game; },\n    get default () { return self; },\n    get MODE_NOSCALE () { return MODE_NOSCALE; },\n    get MODE_CENTER () { return MODE_CENTER; },\n    get MODE_FIT () { return MODE_FIT; },\n    get MODE_STRETCH () { return MODE_STRETCH; },\n    get DisplayPort () { return DisplayPort; },\n    get EventKey () { return EventKey; },\n    get MIN_CONTEXT_PRIORITY () { return MIN_CONTEXT_PRIORITY; },\n    get MAX_CONTEXT_PRIORITY () { return MAX_CONTEXT_PRIORITY; },\n    get createContext () { return createContext; },\n    get createSource () { return createSource; },\n    get AbstractInputAdapter () { return AbstractInputAdapter; },\n    get ActionInputAdapter () { return ActionInputAdapter; },\n    get DOUBLE_ACTION_TIME () { return DOUBLE_ACTION_TIME; },\n    get DoubleActionInputAdapter () { return DoubleActionInputAdapter; },\n    get RangeInputAdapter () { return RangeInputAdapter; },\n    get StateInputAdapter () { return StateInputAdapter; },\n    get Keyboard () { return Keyboard; },\n    get Mouse () { return Mouse; },\n    get RandomGenerator () { return RandomGenerator; },\n    get SimpleRandomGenerator () { return SimpleRandomGenerator; },\n    get Eventable () { return Eventable$1; },\n    get View () { return View; },\n    get ViewHelper () { return ViewHelper; },\n    get ViewPort () { return ViewPort; },\n    get AbstractCamera () { return AbstractCamera; },\n    get GameLoop () { return GameLoop; },\n    get QueryOperator () { return QueryOperator; },\n    get ComponentFactory () { return ComponentFactory; },\n    get Component () { return ComponentHelper; },\n    get Entity () { return EntityHelper; },\n    get EntityWrapper () { return EntityWrapper; },\n    get HotEntityReplacement () { return HotEntityReplacement; },\n    get EntityManager () { return EntityManager; },\n    get EntityQuery () { return EntityQuery; },\n    get ComponentBase () { return ComponentBase; },\n    get TagComponent () { return TagComponent; },\n    get EntityComponent () { return EntityComponent$1; },\n    get EntityBase () { return EntityBase; },\n    get HybridEntity () { return HybridEntity; },\n    get HotEntityModule () { return HotEntityModule; },\n    get FineDiffStrategy () { return FineDiffStrategy; },\n    get SceneManager () { return SceneManager; },\n    get SceneBase () { return SceneBase; }\n});\n\n/**\n * @module DisplayPort\n * @version 1.4\n * \n * # Changelog\n * ## 1.4\n * - Added \"stretch\" mode\n * \n * ## 1.3\n * - Changed \"topleft\" to \"noscale\"\n * - Changed default size to 640 x 480\n * - Changed \"center\" and \"fit\" to fill container instead of viewport\n * - Added \"full\" property to override and fill viewport\n * \n * ## 1.2\n * - Moved default values to the top\n * \n * ## 1.1\n * - Fixed scaling issues when dimensions do not match\n * \n * ## 1.0\n * - Created DisplayPort\n */\n\nconst MODE_NOSCALE = 'noscale';\nconst MODE_CENTER = 'center';\nconst MODE_FIT = 'fit';\nconst MODE_STRETCH = 'stretch';\n\nconst DEFAULT_MODE = MODE_CENTER;\nconst DEFAULT_WIDTH = 640;\nconst DEFAULT_HEIGHT = 480;\n\nconst INNER_HTML = `\n<label class=\"hidden\" id=\"title\">display-port</label>\n<label class=\"hidden\" id=\"fps\">00</label>\n<label class=\"hidden\" id=\"dimension\">0x0</label>\n<canvas></canvas>`;\nconst INNER_STYLE = `\n<style>\n    :host {\n        display: inline-block;\n        color: #555555;\n    }\n    div {\n        display: flex;\n        position: relative;\n        width: 100%;\n        height: 100%;\n    }\n    canvas {\n        background: #000000;\n        margin: auto;\n    }\n    label {\n        font-family: monospace;\n        color: currentColor;\n        position: absolute;\n    }\n    #title {\n        left: 0.5rem;\n        top: 0.5rem;\n    }\n    #fps {\n        right: 0.5rem;\n        top: 0.5rem;\n    }\n    #dimension {\n        left: 0.5rem;\n        bottom: 0.5rem;\n    }\n    .hidden {\n        display: none;\n    }\n    :host([debug]) div {\n        outline: 8px dashed rgba(0, 0, 0, 0.4);\n        outline-offset: -4px;\n        background-color: rgba(0, 0, 0, 0.1);\n    }\n    :host([mode=\"${MODE_NOSCALE}\"]) canvas {\n        margin: 0;\n        top: 0;\n        left: 0;\n    }\n    :host([mode=\"${MODE_FIT}\"]), :host([mode=\"${MODE_CENTER}\"]), :host([mode=\"${MODE_STRETCH}\"]) {\n        width: 100%;\n        height: 100%;\n    }\n    :host([full]) {\n        width: 100vw!important;\n        height: 100vh!important;\n    }\n    :host([disabled]) {\n        display: none;\n    }\n</style>`;\n\nclass DisplayPort extends HTMLElement\n{\n    /** @override */\n    static get observedAttributes()\n    {\n        return [\n            'width',\n            'height',\n            'disabled',\n            // NOTE: For debuggin purposes...\n            'debug',\n            // ...listening for built-in attribs...\n            'id',\n            'class',\n        ];\n    }\n\n    constructor()\n    {\n        super();\n\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.innerHTML = `<div>${INNER_STYLE}${INNER_HTML}</div>`;\n\n        this._canvasElement = this.shadowRoot.querySelector('canvas');\n        this._canvasContext = this._canvasElement.getContext('2d');\n        this._canvasContext.imageSmoothingEnabled = false;\n\n        this._titleElement = this.shadowRoot.querySelector('#title');\n        this._fpsElement = this.shadowRoot.querySelector('#fps');\n        this._dimensionElement = this.shadowRoot.querySelector('#dimension');\n\n        this._animationRequestHandle = 0;\n        this._prevAnimationFrameTime = 0;\n\n        this._width = DEFAULT_WIDTH;\n        this._height = DEFAULT_HEIGHT;\n\n        this.update = this.update.bind(this);\n    }\n\n    /** @override */\n    connectedCallback()\n    {\n        if (!this.hasAttribute('mode')) this.mode = DEFAULT_MODE;\n\n        this.updateCanvasSize();\n        this.resume();\n    }\n\n    /** @override */\n    disconnectedCallback()\n    {\n        this.pause();\n    } \n\n    /** @override */\n    attributeChangedCallback(attribute, prev, value)\n    {\n        switch(attribute)\n        {\n            case 'width':\n                this._width = value;\n                break;\n            case 'height':\n                this._height = value;\n                break;\n            case 'disabled':\n                if (value)\n                {\n                    this.update(0);\n                    this.pause();\n                }\n                else\n                {\n                    this.resume();\n                }\n                break;\n            // NOTE: For debugging purposes...\n            case 'id':\n            case 'class':\n                this._titleElement.innerHTML = `display-port${this.className ? '.' + this.className : ''}${this.hasAttribute('id') ? '#' + this.getAttribute('id') : ''}`;\n                break;\n            case 'debug':\n                this._titleElement.classList.toggle('hidden', value);\n                this._fpsElement.classList.toggle('hidden', value);\n                this._dimensionElement.classList.toggle('hidden', value);\n                break;\n        }\n    }\n\n    update(now)\n    {\n        this._animationRequestHandle = requestAnimationFrame(this.update);\n\n        this.updateCanvasSize();\n\n        // NOTE: For debugging purposes...\n        if (this.debug)\n        {\n            // Update FPS...\n            const dt = now - this._prevAnimationFrameTime;\n            const frames = dt <= 0 ? '--' : String(Math.round(1000 / dt)).padStart(2, '0');\n            this._prevAnimationFrameTime = now;\n            if (this._fpsElement.innerText !== frames)\n            {\n                this._fpsElement.innerText = frames;\n            }\n\n            // Update dimensions...\n            if (this.mode === MODE_NOSCALE)\n            {\n                let result = `${this._width}x${this._height}`;\n                if (this._dimensionElement.innerText !== result)\n                {\n                    this._dimensionElement.innerText = result;\n                }\n            }\n            else\n            {\n                let result = `${this._width}x${this._height}|${this.shadowRoot.host.clientWidth}x${this.shadowRoot.host.clientHeight}`;\n                if (this._dimensionElement.innerText !== result)\n                {\n                    this._dimensionElement.innerText = result;\n                }\n            }\n        }\n\n        this.dispatchEvent(new CustomEvent('frame', { detail: { now, context: this._canvasContext }, bubbles: false, composed: true }));\n    }\n\n    pause()\n    {\n        cancelAnimationFrame(this._animationRequestHandle);\n    }\n\n    resume()\n    {\n        this._animationRequestHandle = requestAnimationFrame(this.update);\n    }\n\n    updateCanvasSize()\n    {\n        let clientRect = this.shadowRoot.host.getBoundingClientRect();\n        const clientWidth = clientRect.width;\n        const clientHeight = clientRect.height;\n\n        let canvas = this._canvasElement;\n        let canvasWidth = this._width;\n        let canvasHeight = this._height;\n\n        const mode = this.mode;\n\n        if (mode === MODE_STRETCH)\n        {\n            canvasWidth = clientWidth;\n            canvasHeight = clientHeight;\n        }\n        else if (mode !== MODE_NOSCALE)\n        {\n            let flag = clientWidth < canvasWidth || clientHeight < canvasHeight || mode === MODE_FIT;\n            if (flag)\n            {\n                let ratioX = clientWidth / canvasWidth;\n                let ratioY = clientHeight / canvasHeight;\n\n                if (ratioX < ratioY)\n                {\n                    canvasWidth = clientWidth;\n                    canvasHeight = canvasHeight * ratioX;\n                }\n                else\n                {\n                    canvasWidth = canvasWidth * ratioY;\n                    canvasHeight = clientHeight;\n                }\n            }\n        }\n\n        canvasWidth = Math.floor(canvasWidth);\n        canvasHeight = Math.floor(canvasHeight);\n\n        if (canvas.width !== canvasWidth || canvas.height !== canvasHeight)\n        {\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            canvas.style = `width: ${canvasWidth}px; height: ${canvasHeight}px`;\n\n            this.dispatchEvent(new CustomEvent('resize', { detail: { width: canvasWidth, height: canvasHeight }, bubbles: false, composed: true }));\n        }\n    }\n\n    getCanvas() { return this._canvasElement; }\n    getContext() { return this._canvasContext; }\n\n    get width() { return this._width; }\n    set width(value) { this.setAttribute('width', value); }\n\n    get height() { return this._height; }\n    set height(value) { this.setAttribute('height', value); }\n\n    get mode() { return this.getAttribute('mode'); }\n    set mode(value) { this.setAttribute('mode', value); }\n\n    get disabled() { return this.hasAttribute('disabled'); }\n    set disabled(value) { if (value) this.setAttribute('disabled', ''); else this.removeAttribute('disabled'); }\n\n    // NOTE: For debugging purposes...\n    get debug() { return this.hasAttribute('debug'); }\n    set debug(value) { if (value) this.setAttribute('debug', ''); else this.removeAttribute('debug'); }\n}\nwindow.customElements.define('display-port', DisplayPort);\n\nconst ANY = Symbol('any');\n\nclass EventKey\n{\n    static parse(eventKeyString)\n    {\n        let startCodeIndex = eventKeyString.indexOf('[');\n        let endCodeIndex = eventKeyString.indexOf(']');\n        let modeIndex = eventKeyString.indexOf('.');\n    \n        let source = null;\n        let code = null;\n        let mode = null;\n    \n        // For ANY source, use `[code].mode` or `.mode`\n        // For ONLY codes and modes from source, use `source`\n        if (startCodeIndex <= 0 || modeIndex === 0) source = ANY;\n        else source = eventKeyString.substring(0, startCodeIndex);\n    \n        // For ANY code, use `source.mode` or `source[].mode`\n        // For ONLY sources and modes for code, use `[code]`\n        if (startCodeIndex < 0 || endCodeIndex < 0 || startCodeIndex + 1 === endCodeIndex) code = ANY;\n        else code = eventKeyString.substring(startCodeIndex + 1, endCodeIndex);\n    \n        // For ANY mode, use `source[code]` or `source[code].`\n        // For ONLY sources and codes for mode, use `.mode`\n        if (modeIndex < 0 || eventKeyString.trim().endsWith('.')) mode = ANY;\n        else mode = eventKeyString.substring(modeIndex + 1);\n    \n        return new EventKey(\n            source,\n            code,\n            mode\n        );\n    }\n\n    constructor(source, code, mode)\n    {\n        this.source = source;\n        this.code = code;\n        this.mode = mode;\n\n        this.string = `${this.source.toString()}[${this.code.toString()}].${this.mode.toString()}`;\n    }\n\n    matches(eventKey)\n    {\n        if (this.source === ANY || eventKey.source === ANY || this.source === eventKey.source)\n        {\n            if (this.code === ANY || eventKey.code === ANY || this.code === eventKey.code)\n            {\n                if (this.mode === ANY || eventKey.mode === ANY || this.mode === eventKey.mode)\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** @override */\n    toString() { return this.string; }\n}\n// NOTE: Exported as a static variable of EventKey\nEventKey.ANY = ANY;\n\nclass AbstractInputAdapter\n{\n    constructor(defaultValue)\n    {\n        this.prev = defaultValue;\n        this.value = defaultValue;\n        this.next = defaultValue;\n    }\n\n    update(eventKey, value) { return false; }\n    consume() { return this.next; }\n\n    poll()\n    {\n        this.prev = this.value;\n        this.value = this.next;\n        this.next = this.consume();\n        return this;\n    }\n}\n\nclass ActionInputAdapter extends AbstractInputAdapter\n{\n    constructor(eventKeyStrings)\n    {\n        super(false);\n\n        this.eventKeys = [];\n        for(let eventKeyString of eventKeyStrings)\n        {\n            this.eventKeys.push(EventKey.parse(eventKeyString));\n        }\n    }\n\n    /** @override */\n    consume() { return false; }\n\n    /** @override */\n    update(eventKey, value = true)\n    {\n        for(let targetEventKey of this.eventKeys)\n        {\n            if (targetEventKey.matches(eventKey))\n            {\n                this.next = value;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nclass RangeInputAdapter extends AbstractInputAdapter\n{\n    constructor(eventKeyString)\n    {\n        super(0);\n\n        this.eventKey = EventKey.parse(eventKeyString);\n    }\n\n    /** @override */\n    consume()\n    {\n        switch(this.eventKey.string)\n        {\n            case 'mouse[pos].dx':\n            case 'mouse[pos].dy':\n                return 0;\n            case 'mouse[pos].x':\n            case 'mouse[pos].y':\n            default:\n                return this.next;\n        }\n    }\n\n    /** @override */\n    update(eventKey, value = 1)\n    {\n        if (this.eventKey.matches(eventKey))\n        {\n            this.next = value;\n            return true;\n        }\n        return false;\n    }\n}\n\nclass StateInputAdapter extends AbstractInputAdapter\n{\n    constructor(eventKeyMap)\n    {\n        super(0);\n        \n        this.eventKeyEntries = [];\n        for(let eventKey of Object.keys(eventKeyMap))\n        {\n            this.eventKeyEntries.push({\n                key: EventKey.parse(eventKey),\n                value: eventKeyMap[eventKey]\n            });\n        }\n    }\n\n    /** @override */\n    update(eventKey, value = true)\n    {\n        if (value)\n        {\n            for(let eventKeyEntry of this.eventKeyEntries)\n            {\n                if (eventKeyEntry.key.matches(eventKey))\n                {\n                    this.next = eventKeyEntry.value;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nconst MIN_CONTEXT_PRIORITY = -100;\nconst MAX_CONTEXT_PRIORITY = 100;\n\nfunction createContext()\n{\n    return {\n        _source: null,\n        _priority: 0,\n        _active: true,\n        inputs: new Map(),\n        get active() { return this._active; },\n        get source() { return this._source; },\n        get priority() { return this._priority; },\n        attach(inputSource)\n        {\n            this._source = inputSource;\n            this._source.addContext(this);\n            return this;\n        },\n        detach()\n        {\n            this._source.removeContext(this);\n            this._source = null;\n            return this;\n        },\n        setPriority(priority)\n        {\n            if (priority > MAX_CONTEXT_PRIORITY || priority < MIN_CONTEXT_PRIORITY)\n            {\n                throw new Error(`Context priority must be between [${MIN_CONTEXT_PRIORITY}, ${MAX_CONTEXT_PRIORITY}].`);\n            }\n            \n            if (this._priority !== priority)\n            {\n                if (this._source)\n                {\n                    this._source.removeContext(this);\n                    this._priority = priority;\n                    this._source.addContext(this);\n                }\n                else\n                {\n                    this._priority = priority;\n                }\n            }\n            return this;\n        },\n        registerInput(name, adapter)\n        {\n            this.inputs.set(name, adapter);\n            return adapter;\n        },\n        registerAction(name, ...eventKeyStrings)\n        {\n            return this.registerInput(name, new ActionInputAdapter(eventKeyStrings));\n        },\n        registerRange(name, eventKeyString)\n        {\n            return this.registerInput(name, new RangeInputAdapter(eventKeyString));\n        },\n        registerState(name, eventKeyMap)\n        {\n            return this.registerInput(name, new StateInputAdapter(eventKeyMap));\n        },\n        toggle(force = undefined)\n        {\n            if (typeof force === 'undefined') force = !this._active;\n            this._active = force;\n            return this;\n        },\n        enable() { return this.toggle(true); },\n        disable() { return this.toggle(false); },\n        poll()\n        {\n            for(let adapter of this.inputs.values())\n            {\n                adapter.poll();\n            }\n        },\n        update(eventKey, value)\n        {\n            let result;\n            for(let adapter of this.inputs.values())\n            {\n                result |= adapter.update(eventKey, value);\n            }\n            return result;\n        }\n    };\n}\n\nclass Mouse\n{\n    constructor()\n    {\n        this.sourceElement = null;\n        this.eventHandler = null;\n\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onMouseUp = this.onMouseUp.bind(this);\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n\n    attach(sourceElement = document)\n    {\n        this.sourceElement = sourceElement;\n        this.sourceElement.addEventListener('mousedown', this.onMouseDown);\n        this.sourceElement.addEventListener('mouseup', this.onMouseUp);\n        this.sourceElement.addEventListener('contextmenu', this.onContextMenu);\n        document.addEventListener('mousemove', this.onMouseMove);\n        return this;\n    }\n\n    detach()\n    {\n        this.sourceElement.removeEventListener('mousedown', this.onMouseDown);\n        this.sourceElement.removeEventListener('mouseup', this.onMouseUp);\n        this.sourceElement.removeEventListener('contextmenu', this.onContextMenu);\n        document.removeEventListener('mousemove', this.onMouseMove);\n        this.sourceElement = null;\n        return this;\n    }\n\n    setEventHandler(eventHandler)\n    {\n        this.eventHandler = eventHandler;\n        return this;\n    }\n\n    onMouseDown(e)\n    {\n        if (!this.eventHandler) return;\n\n        let result;\n        result = this.eventHandler.call(this, `mouse[${e.button}].down`, true);\n\n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    }\n\n    onMouseUp(e)\n    {\n        if (!this.eventHandler) return;\n\n        e.preventDefault();\n        e.stopPropagation();\n        \n        this.eventHandler.call(this, `mouse[${e.button}].up`, true);\n    }\n\n    onMouseMove(e)\n    {\n        if (!this.eventHandler) return;\n\n        const clientCanvas = this.sourceElement;\n        const clientWidth = clientCanvas.clientWidth;\n        const clientHeight = clientCanvas.clientHeight;\n        \n        this.eventHandler.call(this, 'mouse[pos].x', (e.pageX - clientCanvas.offsetLeft) / clientWidth);\n        this.eventHandler.call(this, 'mouse[pos].y', (e.pageY - clientCanvas.offsetTop) / clientHeight);\n        this.eventHandler.call(this, 'mouse[pos].dx', e.movementX / clientWidth);\n        this.eventHandler.call(this, 'mouse[pos].dy', e.movementY / clientHeight);\n    }\n\n    onContextMenu(e)\n    {\n        e.preventDefault();\n        e.stopPropagation();\n    }\n}\n\nclass Keyboard\n{\n    constructor()\n    {\n        this.sourceElement = null;\n        this.eventHandler = null;\n\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n    }\n\n    attach(sourceElement = document)\n    {\n        this.sourceElement = sourceElement;\n        this.sourceElement.addEventListener('keydown', this.onKeyDown);\n        this.sourceElement.addEventListener('keyup', this.onKeyUp);\n        return this;\n    }\n\n    detach()\n    {\n        this.sourceElement.removeEventListener('keydown', this.onKeyDown);\n        this.sourceElement.removeEventListener('keyup', this.onKeyUp);\n        this.sourceElement = null;\n        return this;\n    }\n\n    setEventHandler(eventHandler)\n    {\n        this.eventHandler = eventHandler;\n        return this;\n    }\n\n    onKeyDown(e)\n    {\n        if (!this.eventHandler) return;\n\n        let result;\n        if (e.repeat)\n        {\n            result = this.eventHandler.call(this, `key[${e.key}].repeat`, true);\n        }\n        else\n        {\n            result = this.eventHandler.call(this, `key[${e.key}].down`, true);\n        }\n\n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    }\n\n    onKeyUp(e)\n    {\n        if (!this.eventHandler) return;\n\n        let result;\n        result = this.eventHandler.call(this, `key[${e.key}].up`, true);\n        \n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    }\n}\n\n/**\n * @module InputSource\n */\n\nfunction createSource()\n{\n    let result = {\n        _contexts: new Array(MAX_CONTEXT_PRIORITY - MIN_CONTEXT_PRIORITY),\n        element: null,\n        keyboard: new Keyboard(),\n        mouse: new Mouse(),\n        attach(element)\n        {\n            this.element = element;\n            this.keyboard.attach();\n            this.mouse.attach(element);\n            return this;\n        },\n        detach()\n        {\n            this.element = null;\n            this.keyboard.detach();\n            this.mouse.detach();\n            return this;\n        },\n        addContext(context)\n        {\n            const priority = context.priority - MIN_CONTEXT_PRIORITY;\n            if (!this._contexts[priority]) this._contexts[priority] = [];\n            this._contexts[priority].push(context);\n            return this;\n        },\n        removeContext(context)\n        {\n            const priority = context.priority - MIN_CONTEXT_PRIORITY;\n            let contexts = this._contexts[priority];\n            if (contexts)\n            {\n                contexts.splice(contexts.indexOf(context), 1);\n            }\n            return this;\n        },\n        poll()\n        {\n            for(let contexts of this._contexts)\n            {\n                if (contexts)\n                {\n                    for(let context of contexts)\n                    {\n                        if (context.active)\n                        {\n                            context.poll();\n                        }\n                    }\n                }\n            }\n        },\n        handleEvent(eventKeyString, value)\n        {\n            const eventKey = EventKey.parse(eventKeyString);\n            for(let contexts of this._contexts)\n            {\n                if (contexts)\n                {\n                    for(let context of contexts)\n                    {\n                        if (context.active)\n                        {\n                            let result;\n                            result = context.update(eventKey, value);\n                            if (result)\n                            {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    };\n    result.handleEvent = result.handleEvent.bind(result);\n    result.keyboard.setEventHandler(result.handleEvent);\n    result.mouse.setEventHandler(result.handleEvent);\n    return result;\n}\n\nlet DOUBLE_ACTION_TIME = 300;\n\nclass DoubleActionInputAdapter extends ActionInputAdapter\n{\n    constructor(eventKeyStrings)\n    {\n        super(eventKeyStrings);\n\n        this.actionTime = 0;\n    }\n\n    /** @override */\n    update(eventKey, value = true)\n    {\n        let currentTime = Date.now();\n        for(let targetEventKey of this.eventKeys)\n        {\n            if (targetEventKey.matches(eventKey))\n            {\n                if (value)\n                {\n                    if (currentTime - this.actionTime <= DOUBLE_ACTION_TIME)\n                    {\n                        this.actionTime = 0;\n                        this.next = true;\n                        return true;\n                    }\n                    else\n                    {\n                        this.actionTime = currentTime;\n                        return false;\n                    }\n                }\n                else\n                {\n                    this.next = false;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nclass RandomGenerator\n{\n    constructor(seed)\n    {\n        this._seed = seed;\n    }\n\n    get seed() { return this._seed; }\n\n    random() { return Math.random(); }\n\n    randomRange(min, max)\n    {\n        return this.random() * (max - min) + min;\n    }\n\n    randomChoose(choices)\n    {\n        return choices[Math.floor(this.random() * choices.length)];\n    }\n\n    randomSign()\n    {\n        return this.random() < 0.5 ? -1 : 1;\n    }\n}\n\n// SOURCE: https://gist.github.com/blixt/f17b47c62508be59987b\nclass SimpleRandomGenerator extends RandomGenerator\n{\n    constructor(seed = 0)\n    {\n        super(Math.abs(seed % 2147483647));\n        \n        this._next = this.seed;\n    }\n\n    /** @override */\n    random()\n    {\n        this._next = Math.abs(this._next * 16807 % 2147483647 - 1);\n        return this._next / 2147483646;\n    }\n}\n\n/**\n * @typedef Eventable\n * @property {function} on\n * @property {function} off\n * @property {function} once\n * @property {function} emit\n */\n\n/**\n * @version 1.2\n * \n * # Changelog\n * ## 1.2\n * - Added named exports\n * - Added custom this context\n * - Added some needed explanations for the functions\n * \n * ## 1.1\n * - Started versioning\n */\nconst EventableInstance = {\n    /**\n     * Registers an event handler to continually listen for the event.\n     * \n     * @param {string} event The name of the event to listen for.\n     * @param {function} callback The callback function to handle the event.\n     * @param {*} [handle = callback] The handle to refer to this registered callback.\n     * Used by off() to remove handlers. If none specified, it will use the callback\n     * itself as the handle. This must be unique.\n     * @return {Eventable} Self for method-chaining.\n     */\n    on(event, callback, handle = callback)\n    {\n        let callbacks;\n        if (!this.__events.has(event))\n        {\n            callbacks = new Map();\n            this.__events.set(event, callbacks);\n        }\n        else\n        {\n            callbacks = this.__events.get(event);\n        }\n\n        if (!callbacks.has(handle))\n        {\n            callbacks.set(handle, callback);\n        }\n        else\n        {\n            throw new Error(`Found callback for event '${event}' with the same handle '${handle}'.`);\n        }\n        return this;\n    },\n\n    /**\n     * Unregisters an event handler to stop listening for the event.\n     * \n     * @param {string} event The name of the event listened for.\n     * @param {*} handle The registered handle to refer to the registered\n     * callback. If no handle was provided when calling on(), the callback\n     * is used as the handle instead.\n     * @return {Eventable} Self for method-chaining.\n     */\n    off(event, handle)\n    {\n        if (this.__events.has(event))\n        {\n            const callbacks = this.__events.get(event);\n            if (callbacks.has(handle))\n            {\n                callbacks.delete(handle);\n            }\n            else\n            {\n                throw new Error(`Unable to find callback for event '${event}' with handle '${handle}'.`);\n            }\n        }\n        else\n        {\n            throw new Error(`Unable to find event '${event}'.`);\n        }\n        return this;\n    },\n    \n    /**\n     * Registers a one-off event handler to start listening for the next,\n     * and only the next, event.\n     * \n     * @param {string} event The name of the event to listen for.\n     * @param {function} callback The callback function to handle the event.\n     * @param {*} [handle = callback] The handle to refer to this registered callback.\n     * Used by off() to remove handlers. If none specified, it will use the callback\n     * itself as the handle. This must be unique.\n     * @return {Eventable} Self for method-chaining.\n     */\n    once(event, callback, handle = callback)\n    {\n        const func = (...args) => {\n            this.off(event, handle);\n            callback.apply(this.__context || this, args);\n        };\n        return this.on(event, func, handle);\n    },\n\n    /**\n     * Emits the event with the arguments passed on to the registered handlers.\n     * The context of the handlers, if none were initially bound, could be\n     * defined upon calling the Eventable's creation function. Otherwise, the\n     * handler is called with `this` context of the Eventable instance.\n     * \n     * @param {string} event The name of the event to emit.\n     * @param  {...any} args Any arguments to pass to registered handlers.\n     * @return {Eventable} Self for method-chaining.\n     */\n    emit(event, ...args)\n    {\n        if (this.__events.has(event))\n        {\n            const callbacks = Array.from(this.__events.get(event).values());\n            for(const callback of callbacks)\n            {\n                callback.apply(this.__context || this, args);\n            }\n        }\n        else\n        {\n            this.__events.set(event, new Map());\n        }\n        return this;\n    }\n};\n\n/**\n * Creates an eventable object.\n * \n * @param {Object} [context] The context used for the event handlers.\n * @return {Eventable} The created eventable object.\n */\nfunction create(context = undefined)\n{\n    const result = Object.create(EventableInstance);\n    result.__events = new Map();\n    result.__context = context;\n    return result;\n}\n\n/**\n * Assigns the passed-in object with eventable properties.\n * \n * @param {Object} dst The object to assign with eventable properties.\n * @param {Object} [context] The context used for the event handlers.\n * @return {Eventable} The resultant eventable object.\n */\nfunction assign(dst, context = undefined)\n{\n    const result = Object.assign(dst, EventableInstance);\n    result.__events = new Map();\n    result.__context = context;\n    return result;\n}\n\n/**\n * Mixins eventable properties into the passed-in class.\n * \n * @param {Class} targetClass The class to mixin eventable properties.\n * @param {Object} [context] The context used for the event handlers.\n * @return {Class<Eventable>} The resultant eventable-mixed-in class.\n */\nfunction mixin(targetClass, context = undefined)\n{\n    const targetPrototype = targetClass.prototype;\n    Object.assign(targetPrototype, EventableInstance);\n    targetPrototype.__events = new Map();\n    targetPrototype.__context = context;\n    return targetPrototype;\n}\n\nvar Eventable = {\n    create,\n    assign,\n    mixin\n};\n\nvar Eventable$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create,\n    assign: assign,\n    mixin: mixin,\n    'default': Eventable\n});\n\n/**\n * @module View\n * @version 1.1.0\n * \n * A view is a section of a world that is drawn onto a section of a\n * display. For every view, there must exist a camera and viewport.\n * However, there could exist multiple cameras in the same view\n * (albeit inactive).\n * \n * A viewport is the section of the display that shows the content.\n * Since viewports generally change with the display, it is calculated\n * when needed rather than stored. Usually, you only want the full display\n * as a viewport.\n * \n * A camera is the view in the world space itself. This usually means\n * it has the view and projection matrix. And because of its existance\n * within the world, it is often manipulated to change the world view.\n * \n * Another way to look at it is that viewports hold the destination\n * dimensions of a view, whilst the camera holds the source transformations\n * that are applied to a view's source canvas (its buffer) dimension.\n * The size of the view buffer should never change (unless game resolution\n * and aspect ratio changes).\n */\n\n/**\n * Creates a view which facilitates rendering from world to screen space.\n */\nfunction createView(width = 640, height = 480)\n{\n    let { canvas, context } = createViewBuffer(width, height);\n    return {\n        _canvas: canvas,\n        _context: context,\n        _width: width,\n        _height: height,\n\n        get canvas() { return this._canvas; },\n        get context() { return this._context; },\n\n        get width() { return this._width; },\n        set width(value)\n        {\n            this._width = value;\n            this._canvas.width = value;\n        },\n        get height() { return this._height; },\n        set height(value)\n        {\n            this._height = value;\n            this._canvas.height = value;\n        },\n    };\n}\n\nfunction createViewBuffer(width, height)\n{\n    let canvasElement = document.createElement('canvas');\n    canvasElement.width = width;\n    canvasElement.height = height;\n    canvasElement.style = 'image-rendering: pixelated';\n    let canvasContext = canvasElement.getContext('2d');\n    canvasContext.imageSmoothingEnabled = false;\n    return { canvas: canvasElement, context: canvasContext };\n}\n\nfunction drawBufferToCanvas(\n    targetCanvasContext,\n    bufferCanvasElement,\n    viewPortX = 0,\n    viewPortY = 0,\n    viewPortWidth = targetCanvasContext.canvas.clientWidth,\n    viewPortHeight = targetCanvasContext.canvas.clientHeight)\n{\n    targetCanvasContext.drawImage(bufferCanvasElement,\n        viewPortX, viewPortY, viewPortWidth, viewPortHeight);\n}\n\nvar View = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createView: createView,\n    createViewBuffer: createViewBuffer,\n    drawBufferToCanvas: drawBufferToCanvas\n});\n\nfunction setViewTransform(view, camera = undefined)\n{\n    if (camera)\n    {\n        view.context.setTransform(...camera.getProjectionMatrix());\n        view.context.transform(...camera.getViewMatrix());\n    }\n    else\n    {\n        view.context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n}\n\nvar ViewHelper = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setViewTransform: setViewTransform\n});\n\n/**\n * A viewport for a display output. This serves as the output dimensions of a view.\n * @param {HTMLElement} canvasElement The output canvas (or the display).\n * @param {RenderingContext} canvasContext The output canvas context.\n */\nclass ViewPort\n{\n    constructor(canvasElement, canvasContext)\n    {\n        this._canvas = canvasElement;\n        this._context = canvasContext;\n    }\n\n    // NOTE: We use function getters instead of property getters here because\n    // this can easily be overridden for a different implementation. These\n    // values are expected to support both computed and stored values. Whereas\n    // property getters imply a static, or stored, value.\n\n    /** The x position offset in the output. */\n    getX() { return 0; }\n    /** The y position offset in the output. */\n    getY() { return 0; }\n    /** The width of the viewport in the output. */\n    getWidth() { return this._canvas.clientWidth; }\n    /** The height of the viewport in the output. */\n    getHeight() { return this._canvas.clientHeight; }\n    \n    /** The output canvas element. */\n    getCanvas() { return this._canvas; }\n    /** The output canvas context. */\n    getContext() { return this._context; }\n}\n\n/**\n * A camera for a view. This serves as the in-world representation of the\n * view. This is usually manipulated to move the world, zoom in, etc.\n */\nclass AbstractCamera\n{\n    /** @abstract */\n    getProjectionMatrix() { return [1, 0, 0, 1, 0, 0]; }\n    /** @abstract */\n    getViewMatrix() { return [1, 0, 0, 1, 0, 0]; }\n}\n\n/**\n * @version 1.3.0\n * @description\n * Handles a steady update loop.\n * \n * # Changelog\n * ## 1.3.0\n * - Removed frameTime in favor of deltaTimeFactor\n * - Moved static start()/stop() for game loop to modules\n * \n * ## 1.2.0\n * - Fixed incrementing dt on window blur\n * - Fixed large dt on first frame\n * \n * ## 1.1.0\n * - Added pause and resume\n * \n * ## 1.0.0\n * - Create GameLoop\n * \n * @property {Number} prevFrameTime The time of the previous frame in milliseconds.\n * @property {Object} animationFrameHandle The handle for the animation frame request. Used by cancelAnimationRequest().\n * @property {Object} gameContext The context of the game loop to run in.\n * @property {Object} deltaTimeFactor The value multiplied to dt for the update call.\n * @property {Object} started Whether the game has started.\n * @property {Object} paused Whether the game is paused.\n * \n * @fires start\n * @fires stop\n * @fires pause\n * @fires resume\n * @fires update\n */\nclass GameLoop\n{\n    constructor(context = {})\n    {\n        this.prevFrameTime = 0;\n        this.animationFrameHandle = null;\n        this.started = false;\n        this.paused = false;\n        this.deltaTimeFactor = 1 / 1000;\n\n        this.gameContext = context;\n\n        this.run = this.run.bind(this);\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        this.pause = this.pause.bind(this);\n        this.resume = this.resume.bind(this);\n\n        // HACK: This overrides Eventable's callback context.\n        this.__context = context;\n    }\n\n    setDeltaTimeFactor(value)\n    {\n        this.deltaTimeFactor = value;\n        return this;\n    }\n\n    /** Runs the game loop. Will call itself. */\n    run(now)\n    {\n        this.animationFrameHandle = requestAnimationFrame(this.run);\n        const dt = (now - this.prevFrameTime) * this.deltaTimeFactor;\n        this.prevFrameTime = now;\n\n        if (typeof this.gameContext.update === 'function') this.gameContext.update.call(this.gameContext, dt);\n        this.emit('update', dt);\n    }\n\n    /** Starts the game loop. Calls run(). */\n    start()\n    {\n        if (this.started) throw new Error('Loop already started.');\n\n        // If the window is out of focus, just ignore the time.\n        window.addEventListener('focus', this.resume);\n        window.addEventListener('blur', this.pause);\n\n        this.prevFrameTime = performance.now();\n        this.started = true;\n\n        if (typeof this.gameContext.start === 'function') this.gameContext.start.call(this.gameContext);\n        this.emit('start');\n\n        this.run(this.prevFrameTime);\n    }\n\n    /** Stops the game loop. */\n    stop()\n    {\n        if (!this.started) throw new Error('Loop not yet started.');\n\n        // If the window is out of focus, just ignore the time.\n        window.removeEventListener('focus', this.resume);\n        window.removeEventListener('blur', this.pause);\n\n        cancelAnimationFrame(this.animationFrameHandle);\n        this.animationFrameHandle = null;\n        this.started = false;\n\n        if (typeof this.gameContext.stop === 'function') this.gameContext.stop.call(this.gameContext);\n        this.emit('stop');\n    }\n\n    /** Pauses the game loop. */\n    pause()\n    {\n        if (!this.started || this.paused) return;\n\n        cancelAnimationFrame(this.animationFrameHandle);\n        this.animationFrameHandle = null;\n        this.paused = true;\n\n        if (typeof this.gameContext.pause === 'function') this.gameContext.pause.call(this.gameContext);\n        this.emit('pause');\n    }\n\n    /** Resumes the game loop. */\n    resume()\n    {\n        if (!this.started || !this.pause) return;\n\n        this.prevFrameTime = performance.now();\n        this.paused = false;\n\n        if (typeof this.gameContext.resume === 'function') this.gameContext.resume.call(this.gameContext);\n        this.emit('resume');\n\n        this.run(this.prevFrameTime);\n    }\n}\nmixin(GameLoop);\n\nfunction getComponentTypeName$1(componentType)\n{\n    return componentType.name || componentType.toString();\n}\n\nvar ComponentHelper = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getComponentTypeName: getComponentTypeName$1\n});\n\nconst OPERATOR$1 = Symbol('operator');\nconst HANDLER$1 = Symbol('handler');\n\n/**\n * NOTE: Intentionally does not depend on the \"entityManager\" to exist in order to be created.\n */\nclass EntityQuery\n{\n    static select(entityManager, components)\n    {\n        return new EntityQuery(components, false).select(entityManager);\n    }\n\n    static computeKey(components)\n    {\n        let result = [];\n        for(let component of components)\n        {\n            if (typeof component === 'object' && OPERATOR$1 in component)\n            {\n                result.push(component[OPERATOR$1].toString() + getComponentTypeName$1(component));\n            }\n            else\n            {\n                result.push(getComponentTypeName$1(component));\n            }\n        }\n        return result.sort().join('-');\n    }\n\n    constructor(components, persistent = true)\n    {\n        this._included = [];\n        this._operated = {};\n\n        for(let component of components)\n        {\n            if (typeof component === 'object' && OPERATOR$1 in component)\n            {\n                const operator = component[OPERATOR$1];\n                if (operator in this._operated)\n                {\n                    this._operated[operator].components.push(component.component);\n                }\n                else\n                {\n                    this._operated[operator] = {\n                        components: [component.component],\n                        handler: component[HANDLER$1],\n                    };\n                }\n            }\n            else\n            {\n                this._included.push(component);\n            }\n        }\n\n        this.entityManager = null;\n        this.persistent = persistent;\n        this.entityIds = new Set();\n\n        this.key = EntityQuery.computeKey(components);\n\n        this.onEntityCreate = this.onEntityCreate.bind(this);\n        this.onEntityDestroy = this.onEntityDestroy.bind(this);\n        this.onComponentAdd = this.onComponentAdd.bind(this);\n        this.onComponentRemove = this.onComponentRemove.bind(this);\n    }\n\n    matches(entityManager, entityId)\n    {\n        if (this.entityManager !== entityManager) return false;\n        if (!entityManager.hasComponent(entityId, ...this._included)) return false;\n        for(let operatedInfo of Object.getOwnPropertyNames(this._operated))\n        {\n            if (!operatedInfo[HANDLER$1].call(this, entityManager, entityId, operatedInfo.components))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    select(entityManager)\n    {\n        let flag = this.entityManager === entityManager;\n        if (this.persistent && flag) return this.entityIds;\n        \n        const prevEntityManager = this.entityManager;\n        this.entityManager = entityManager;\n        this.entityIds.clear();\n\n        for(let entityId of entityManager.getEntityIds())\n        {\n            if (this.matches(entityManager, entityId))\n            {\n                this.entityIds.add(entityId);\n            }\n        }\n\n        if (this.persistent && !flag)\n        {\n            if (prevEntityManager)\n            {\n                prevEntityManager.entityHandler.off('create', this.onEntityCreate);\n                prevEntityManager.entityHandler.off('destroy', this.onEntityDestroy);\n                prevEntityManager.componentHandler.off('add', this.onComponentAdd);\n                prevEntityManager.componentHandler.off('remove', this.onComponentRemove);\n            }\n\n            this.entityManager.entityHandler.on('create', this.onEntityCreate);\n            this.entityManager.entityHandler.on('destroy', this.onEntityDestroy);\n            this.entityManager.componentHandler.on('add', this.onComponentAdd);\n            this.entityManager.componentHandler.on('remove', this.onComponentRemove);\n        }\n\n        return this.entityIds;\n    }\n\n    selectComponent(entityManager, component = this._included[0])\n    {\n        let result = this.select(entityManager);\n        let dst = [];\n        for(let entityId of result)\n        {\n            dst.push(entityManager.getComponent(entityId, component));\n        }\n        return dst;\n    }\n\n    clear()\n    {\n        if (this.persistent)\n        {\n            this.entityManager.entityHandler.off('create', this.onEntityCreate);\n            this.entityManager.entityHandler.off('destroy', this.onEntityDestroy);\n            this.entityManager.componentHandler.off('add', this.onComponentAdd);\n            this.entityManager.componentHandler.off('remove', this.onComponentRemove);\n        }\n\n        this.entityIds.clear();\n        this.entityManager = null;\n    }\n\n    onEntityCreate(entityId)\n    {\n        if (this.matches(this.entityManager, entityId))\n        {\n            this.entityIds.add(entityId);\n        }\n    }\n\n    onEntityDestroy(entityId)\n    {\n        if (this.entityIds.has(entityId))\n        {\n            this.entityIds.delete(entityId);\n        }\n    }\n\n    onComponentAdd(entityId, componentType, component, initialValues)\n    {\n        this.onComponentRemove(entityId, componentType, component);\n    }\n    \n    // NOTE: Could be further optimized if we know it ONLY contains includes, etc.\n    onComponentRemove(entityId, componentType, component)\n    {\n        if (this.matches(this.entityManager, entityId))\n        {\n            this.entityIds.add(entityId);\n        }\n        else if (this.entityIds.has(entityId))\n        {\n            this.entityIds.delete(entityId);\n        }\n    }\n}\n\n/**\n * @fires destroy\n */\nclass EntityHandler\n{\n    constructor()\n    {\n        this._entities = new Set();\n        this._nextAvailableEntityId = 1;\n        this._listeners = new Map();\n    }\n\n    /**\n     * Adds a listener for entity events that occur for the passed-in id.\n     * \n     * @param {EntityId} entityId The associated id for the entity to listen to.\n     * @param {String} eventType The event type to listen for.\n     * @param {Function} listener The listener function that will be called when the event occurs.\n     * @param {Object} [opts] Additional options.\n     * @param {Boolean} [opts.once=false] Whether the listener should be invoked at most once after being\n     * added. If true, the listener would be automatically removed when invoked.\n     * @param {Function|String|*} [opts.handle=listener] The handle to uniquely identify the listener. If set,\n     * this will be used instead of the function instance. This is usful for anonymous functions, since\n     * they are always unique and therefore cannot be removed, causing an unfortunate memory leak.\n     */\n    addEntityListener(entityId, eventType, listener, opts = undefined)\n    {\n        const handle = opts && typeof opts.handle !== 'undefined' ? opts.handle : listener;\n        \n        if (this._listeners.has(entityId))\n        {\n            let eventMap = this._listeners.get(entityId);\n            if (eventType in eventMap)\n            {\n                let listeners = eventMap[eventType];\n                listeners.set(handle, listener);\n            }\n            else\n            {\n                let listeners = new Map();\n                listeners.set(handle, listener);\n                eventMap[eventType] = listeners;\n            }\n        }\n        else\n        {\n            let onces = new Set();\n            let listeners = new Map();\n            listeners.set(handle, listener);\n            if (opts.once) onces.add(handle);\n            let eventMap = {\n                onces,\n                [eventType]: listeners\n            };\n            this._listeners.set(entityId, eventMap);\n        }\n    }\n\n    /**\n     * Removes the listener from the entity with the passed-in id.\n     * \n     * @param {EntityId} entityId The associated id for the entity to remove from.\n     * @param {String} eventType The event type to remove from.\n     * @param {Function|String|*} handle The listener handle that will be called when the event occurs.\n     * Usually, this is the function itself.\n     * @param {Object} [opts] Additional options.\n     */\n    removeEntityListener(entityId, eventType, handle, opts = undefined)\n    {\n        if (this._listeners.has(entityId))\n        {\n            let eventMap = this._listeners.get(entityId);\n            if (eventType in eventMap)\n            {\n                eventMap[eventType].delete(handle);\n                if (eventMap.onces.has(handle))\n                {\n                    eventMap.onces.delete(handle);\n                }\n            }\n        }\n    }\n\n    /**\n     * Dispatches an event to all the entity's listeners.\n     * \n     * @param {EntityId} entityId The id of the entity.\n     * @param {String} eventType The type of the dispatched event.\n     * @param {Array} [eventArgs] An array of arguments to be passed to the listeners.\n     */\n    dispatchEntityEvent(entityId, eventType, eventArgs = undefined)\n    {\n        if (this._listeners.has(entityId))\n        {\n            let eventMap = this._listeners.get(entityId);\n            if (eventType in eventMap)\n            {\n                let onces = eventMap.onces;\n                let listeners = eventMap[eventType];\n                for(let [handle, listener] of listeners.entries())\n                {\n                    listener.apply(undefined, eventArgs);\n                    if (onces.has(handle))\n                    {\n                        listeners.delete(handle);\n                    }\n                }\n            }\n        }\n    }\n\n    addEntityId(entityId)\n    {\n        this._entities.add(entityId);\n    }\n\n    deleteEntityId(entityId)\n    {\n        this._entities.delete(entityId);\n        this.dispatchEntityEvent(entityId, 'destroy', [ entityId ]);\n    }\n    \n    getNextAvailableEntityId()\n    {\n        return this._nextAvailableEntityId++;\n    }\n\n    getEntityIds()\n    {\n        return this._entities;\n    }\n}\n\n/** Cannot be directly added through world.addComponent(). Must be create with new EntityComponent(). */\nclass EntityComponent$1\n{\n    constructor(world)\n    {\n        if (!world)\n        {\n            throw new Error('Cannot create entity in null world.');\n        }\n\n        const id = world.createEntity();\n\n        // Skip component creation, as we will be using ourselves :D\n        world.componentHandler.putComponent(id, EntityComponent$1, this, undefined);\n        \n        this.id = id;\n    }\n\n    /** @override */\n    copy(values) { throw new Error('Unsupported operation; cannot be initialized by existing values.'); }\n    \n    /** @override */\n    reset() { return false; }\n}\n\n/**\n * @fires componentadd\n * @fires componentremove\n */\nclass ComponentHandler\n{\n    constructor(entityHandler)\n    {\n        this._entityHandler = entityHandler;\n        this.componentTypeInstanceMap = new Map();\n    }\n\n    createComponent(componentType, initialValues)\n    {\n        let component;\n\n        // Instantiate the component...\n        let type = typeof componentType;\n        if (type === 'object')\n        {\n            // NOTE: Although this checks the prototype chain on EVERY add, it only\n            // checks on the class object, which should NOT have a chain.\n            if (!('create' in componentType))\n            {\n                throw new Error(`Instanced component class '${getComponentTypeName(componentType)}' must at least have a create() function.`);\n            }\n\n            component = componentType.create(this);\n        }\n        else if (type === 'function')\n        {\n            // HACK: This is a hack debugging tool to stop wrong use.\n            if (componentType.prototype instanceof EntityComponent$1)\n            {\n                throw new Error('This component cannot be added to an existing entity; it can only initialize itself.');\n            }\n\n            component = new componentType(this);\n        }\n        else if (type === 'symbol')\n        {\n            // NOTE: Symbols lose their immutability when converted into a component\n            // (their equality is checked by their toString() when computing its key)\n            throw new Error('Symbols are not yet supported as components.');\n        }\n        else\n        {\n            // NOTE: This means that these can be numbers and strings.\n            // HOWEVER, I caution against using numbers. Numbers can often be confused\n            // with other operations (particularly when computation is involved).\n            component = componentType;\n        }\n\n        // Initialize the component...\n        if (initialValues)\n        {\n            this.copyComponent(componentType, component, initialValues);\n        }\n        \n        return component;\n    }\n\n    putComponent(entityId, componentType, component, initialValues)\n    {\n        let componentInstanceMap;\n        if (this.componentTypeInstanceMap.has(componentType))\n        {\n            componentInstanceMap = this.componentTypeInstanceMap.get(componentType);\n        }\n        else\n        {\n            this.componentTypeInstanceMap.set(componentType, componentInstanceMap = new Map());\n        }\n\n        if (componentInstanceMap.has(entityId))\n        {\n            throw new Error(`Cannot add more than one instance of component class '${getComponentTypeName(componentType)}' for entity '${entityId}'.`);\n        }\n\n        componentInstanceMap.set(entityId, component);\n\n        this._entityHandler.dispatchEntityEvent(entityId, 'componentadd', [entityId, componentType, component, initialValues]);\n    }\n\n    deleteComponent(entityId, componentType, component)\n    {\n        this.componentTypeInstanceMap.get(componentType).delete(entityId);\n    \n        let reusable;\n        // It's a tag. No reuse.\n        if (componentType === component)\n        {\n            reusable = false;\n        }\n        // Try user-defined static reset...\n        else if ('reset' in componentType)\n        {\n            reusable = componentType.reset(component);\n        }\n        // Try user-defined instance reset...\n        else if ('reset' in component)\n        {\n            reusable = component.reset();\n        }\n        // Try default reset...\n        else\n        {\n            // Do nothing. It cannot be reset.\n            reusable = false;\n        }\n\n        this._entityHandler.dispatchEntityEvent(entityId, 'componentremove', [entityId, componentType, component]);\n        return component;\n    }\n\n    copyComponent(componentType, component, targetValues)\n    {\n        // It's a tag. No need to copy.\n        if (componentType === component)\n        {\n            return;\n        }\n        // Try user-defined static copy...\n        else if ('copy' in componentType)\n        {\n            componentType.copy(component, targetValues);\n        }\n        // Try user-defined instance copy...\n        else if ('copy' in component)\n        {\n            component.copy(targetValues);\n        }\n        // Try default copy...\n        else\n        {\n            for(let key of Object.getOwnPropertyNames(targetValues))\n            {\n                component[key] = targetValues[key];\n            }\n        }\n    }\n\n    hasComponentType(componentType)\n    {\n        return this.componentTypeInstanceMap.has(componentType);\n    }\n\n    getComponentTypes()\n    {\n        return this.componentTypeInstanceMap.keys();\n    }\n\n    getComponentInstanceMapByType(componentType)\n    {\n        return this.componentTypeInstanceMap.get(componentType);\n    }\n\n    getComponentInstanceMaps()\n    {\n        return this.componentTypeInstanceMap.values();\n    }\n}\n\n/**\n * @typedef EntityId\n * The unique id for every entity in a world.\n */\n\n/**\n * Manages all entities.\n */\nclass EntityManager\n{\n    constructor()\n    {\n        this.entityHandler = new EntityHandler();\n        this.componentHandler = new ComponentHandler(this.entityHandler);\n    }\n\n    clear()\n    {\n        for(let entityId of this.entityHandler.getEntityIds())\n        {\n            this.destroyEntity(entityId);\n        }\n    }\n\n    /** Creates a unique entity with passed-in components (without initial values). */\n    createEntity(...components)\n    {\n        const entityId = this.entityHandler.getNextAvailableEntityId();\n        this.entityHandler.addEntityId(entityId);\n\n        for(let component of components)\n        {\n            this.addComponent(entityId, component);\n        }\n        return entityId;\n    }\n\n    /** Destroys the passed-in entity (and its components). */\n    destroyEntity(entityId)\n    {\n        // Remove entity components from world\n        for(let componentType of this.componentHandler.getComponentTypes())\n        {\n            if (this.componentHandler.getComponentInstanceMapByType(componentType).has(entityId))\n            {\n                this.removeComponent(entityId, componentType);\n            }\n        }\n\n        // Remove entity from world\n        this.entityHandler.deleteEntityId(entityId);\n    }\n\n    getEntityIds()\n    {\n        return this.entityHandler.getEntityIds();\n    }\n    \n    /**\n     * \n     * @param {import('./Entity.js').EntityId} entityId The id of the entity to add to.\n     * @param {FunctionConstructor|import('./Component.js').ComponentFactory|String|Number} componentType The component type.\n     * Can either be a component class or a component factory.\n     * @param {Object} [initialValues] The initial values for the component. Can be an object\n     * map of all defined key-value pairs or another instance of the same component. This\n     * must be undefined for tag-like components.\n     */\n    addComponent(entityId, componentType, initialValues = undefined)\n    {\n        try\n        {\n            let component = this.componentHandler.createComponent(componentType, initialValues);\n            this.componentHandler.putComponent(entityId, componentType, component, initialValues);\n            return component;\n        }\n        catch(e)\n        {\n            console.error(`Failed to add component '${getComponentTypeName$1(componentType)}' to entity '${entityId}'.`);\n            console.error(e);\n        }\n    }\n    \n    removeComponent(entityId, componentType)\n    {\n        try\n        {\n            let component = this.getComponent(entityId, componentType);\n            this.componentHandler.deleteComponent(entityId, componentType, component);\n            return component;\n        }\n        catch(e)\n        {\n            console.error(`Failed to remove component '${getComponentTypeName$1(componentType)}' from entity '${entityId}'.`);\n            console.error(e);\n        }\n    }\n\n    clearComponents(entityId)\n    {\n        for(let componentInstanceMap of this.componentHandler.getComponentInstanceMaps())\n        {\n            if (componentInstanceMap.has(entityId))\n            {\n                let component = componentInstanceMap.get(entityId);\n                this.componentHandler.deleteComponent(entityId, componentType, component);\n            }\n        }\n    }\n\n    getComponentTypesByEntityId(entityId)\n    {\n        let dst = [];\n        for(let componentType of this.componentHandler.getComponentTypes())\n        {\n            let componentInstanceMap = this.componentHandler.getComponentInstanceMapByType(componentType);\n            if (componentInstanceMap.has(entityId))\n            {\n                dst.push(componentType);\n            }\n        }\n        return dst;\n    }\n\n    getComponent(entityId, componentType)\n    {\n        return this.componentHandler.getComponentInstanceMapByType(componentType).get(entityId);\n    }\n\n    hasComponent(entityId, ...componentTypes)\n    {\n        for(let componentType of componentTypes)\n        {\n            if (!this.componentHandler.hasComponentType(componentType)) return false;\n            if (!this.componentHandler.getComponentInstanceMapByType(componentType).has(entityId)) return false;\n        }\n        return true;\n    }\n\n    countComponents(entityId)\n    {\n        let count = 0;\n        for(let componentInstanceMap of this.componentHandler.getComponentInstanceMaps())\n        {\n            if (componentInstanceMap.has(entityId))\n            {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Immediately find entity ids by its components. This is simply an alias for Query.select().\n     * @param {Array<Component>} components The component list to match entities to.\n     * @returns {Iterable<EntityId>} A collection of all matching entity ids.\n     */\n    find(components)\n    {\n        return EntityQuery.select(this, components);\n    }\n\n    [Symbol.iterator]()\n    {\n        return this.getEntityIds()[Symbol.iterator]();\n    }\n}\n\nfunction createQueryOperator(handler, key = Symbol(handler.name))\n{\n    let result = function(componentType) {\n        return { [OPERATOR]: key, [HANDLER]: handler, component: componentType };\n    };\n    // Dynamic renaming of function for debugging purposes\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n    Object.defineProperty(result, 'name', {\n        value: name,\n        configurable: true,\n    });\n    return result;\n}\n\nconst Not = createQueryOperator(\n    function NotOperator(world, entityId, componentTypees)\n    {\n        return !(world.hasComponent(entityId, ...componentTypees));\n    },\n    Symbol('!')\n);\n\nvar QueryOperator = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createQueryOperator: createQueryOperator,\n    Not: Not\n});\n\n/**\n * Creates a new component instance for this component type.\n * @callback create\n * @param {import('../World.js').World} world The world the component will be added to.\n * @param {import('../entity/Entity.js').EntityId} entityId The id of the entity this component is added to.\n */\n\n/**\n * Copies a component instance from values.\n * @callback copy\n * @param {Object} dst The target component instance to modify.\n * @param {Object} values The source values to copy from.\n */\n\n/**\n * Resets a component instance to be re-used or deleted.\n * @callback reset\n * @param {Object} dst The target component instance to reset.\n */\n\n/**\n * @typedef ComponentFactory\n * A component factory handles the creation, modification, and deletion of component instances.\n * \n * @property {create} create Creates a new component instance for this type.\n * @property {copy} [copy] Copies a component instance from values.\n * @property {reset} [reset] Resets a component instance to be re-used or deleted.\n */\n\n/**\n * Creates a component factory given the passed-in handlers. This is not required\n * to create a component factory; any object with create(), copy(), and reset() can\n * be considered a component factory and used as is without this function. This\n * function is mostly for ease of use and readability.\n * \n * @param {String} name The name of the component. This should be unique; it is used as its hash key.\n * @param {create} [create=defaultCreate] The function to create new components.\n * @param {copy} [copy=defaultCopy] The function to copy new components from values.\n * @param {reset} [reset=defaultReset] The function to reset a component to be re-used or deleted.\n * @returns {ComponentFactory} The created component factory.\n */\nfunction createComponentFactory(name, create = defaultCreate, copy = defaultCopy, reset = defaultReset)\n{\n    return {\n        name,\n        create,\n        copy,\n        reset\n    };\n}\n\nfunction defaultCreate(world, entityId) { return {}; }\nfunction defaultCopy(dst, values) { Object.assign(dst, values); }\nfunction defaultReset(dst) { Object.getOwnPropertyNames(dst).forEach(value => delete dst[value]); }\n\nvar ComponentFactory = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createComponentFactory: createComponentFactory\n});\n\n/**\n * A class to represent a component. This class is not required to\n * create a component; any class can be considered a component. To\n * override reset or copy behavior, simply implement the reset()\n * or copy() functions respectively for that class.\n * \n * This class serves mostly as a quick and dirty default fallback. It\n * has defaults for all functionality except its properties (which are\n * usually unique to each component type).\n * \n * Usually, you will use this class like so:\n * @example\n * class MyComponent extends ComponentBase\n * {\n *   constructor()\n *   {\n *     super();\n *     this.myValue = true;\n *     this.myString = 'Hello World';\n *   }\n * \n *   // Feel free to override any default functionality when needed...\n * }\n */\nconst DEFAULT_UNDEFINED = Symbol('defaultUndefined');\nclass ComponentBase\n{\n    static get defaultValues() { return null; }\n\n    constructor(world, entityId, resetAsSelfConstructor = true)\n    {\n        if (!('defaultValues' in this.constructor))\n        {\n            if (resetAsSelfConstructor)\n            {\n                // NOTE: Must make sure 'defaultValues' exists before recursing into the constructor.\n                this.constructor.defaultValues = null;\n                this.constructor.defaultValues = new (this.constructor)();\n            }\n            else\n            {\n                this.constructor.defaultValues = DEFAULT_UNDEFINED;\n            }\n        }\n    }\n    \n    copy(values)\n    {\n        for(let key of Object.getOwnPropertyNames(values))\n        {\n            this[key] = values[key];\n        }\n    }\n\n    reset()\n    {\n        if ('defaultValues' in this.constructor)\n        {\n            let defaultValues = this.constructor.defaultValues;\n            if (defaultValues === DEFAULT_UNDEFINED)\n            {\n                for(let key of Object.getOwnPropertyNames(this))\n                {\n                    this[key] = undefined;\n                }\n                return true;\n            }\n            else if (defaultValues)\n            {\n                this.copy(this, this.constructor.defaultValues);\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            return false;\n        }\n    }\n}\n\n/**\n * A class to represent a component with no data, also known as a tag.\n * This class is not required to create a tag component; any class is\n * considered a tag, if:\n * \n * - It does not implement reset() or reset() always returns false.\n * - And its instances do not own any properties.\n * \n * This class is mostly for ease of use and readability.\n */\nclass TagComponent {}\n\nclass EntityBase extends EntityComponent$1\n{\n    constructor(entityManager)\n    {\n        super(entityManager);\n\n        this.entityManager = entityManager;\n    }\n\n    destroy()\n    {\n        this.entityManager.destroyEntity(this.entityId);\n        this.entityManager = null;\n    }\n\n    addComponent(componentType, initialValues = undefined)\n    {\n        this.entityManager.addComponent(this.id, componentType, initialValues);\n        return this;\n    }\n\n    removeComponent(componentType)\n    {\n        this.entityManager.removeComponent(this.id, componentType);\n        return this;\n    }\n\n    hasComponent(componentType)\n    {\n        return this.entityManager.hasComponent(this.id, componentType);\n    }\n\n    getComponent(componentType)\n    {\n        return this.entityManager.getComponent(this.id, componentType);\n    }\n}\n\nclass HybridEntity extends EntityBase\n{\n    constructor(entityManager)\n    {\n        super(entityManager);\n\n        this.onComponentAdd = this.onComponentAdd.bind(this);\n        this.onComponentRemove = this.onComponentRemove.bind(this);\n\n        this.entityManager.entityHandler.addEntityListener(this.id, 'componentadd', this.onComponentAdd);\n        this.entityManager.entityHandler.addEntityListener(this.id, 'componentremove', this.onComponentRemove);\n    }\n    \n    /** @abstract */\n    onDestroy() {}\n\n    onComponentAdd(entityId, componentType, component, initialValues)\n    {\n        if (entityId === this.id)\n        {\n            // NOTE: Since this callback is connected only AFTER EntityComponent has been added\n            // we can safely assume that it cannot be added again.\n            addComponentProperties(this, componentType, component);\n        }\n    }\n\n    onComponentRemove(entityId, componentType, component)\n    {\n        if (componentType === EntityComponent)\n        {\n            this.entityManager.entityHandler.removeEntityListener(this.id, 'componentadd', this.onComponentAdd);\n            this.entityManager.entityHandler.removeEntityListener(this.id, 'componentremove', this.onComponentRemove);\n            \n            this.onDestroy();\n        }\n        else\n        {\n            removeComponentProperties(this, componentType, component);\n        }\n    }\n}\n\nfunction addComponentProperties(target, componentType, component)\n{\n    if (typeof component === 'object')\n    {\n        let ownProps = Object.getOwnPropertyNames(target);\n        let newProps = {};\n        for(let prop of Object.getOwnPropertyNames(component))\n        {\n            if (ownProps.includes(prop))\n            {\n                throw new Error(`Conflicting property names in entity for component '${getComponentTypeName(componentType)}'.`);\n            }\n\n            newProps[prop] = {\n                get() { return component[prop]; },\n                set(value) { component[prop] = value; },\n                configurable: true,\n            };\n        }\n        Object.defineProperties(target, newProps);\n    }\n}\n\nfunction removeComponentProperties(target, componentType, component)\n{\n    if (typeof component === 'object')\n    {\n        for(let prop of Object.getOwnPropertyNames(component))\n        {\n            delete target[prop];\n        }\n    }\n}\n\nfunction getEntityById(world, entityId)\n{\n    return getComponent(entityId, EntityComponent);\n}\n\nfunction getEntities(world)\n{\n    let dst = [];\n    let entityIds = world.query([EntityComponent]);\n    for(let entityId of entityIds)\n    {\n        let component = world.getComponent(entityId, EntityComponent);\n        dst.push(component);\n    }\n    return dst;\n}\n\nvar EntityHelper = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getEntityById: getEntityById,\n    getEntities: getEntities\n});\n\nclass EntityWrapperBase\n{\n    constructor(entityManager)\n    {\n        this.entityManager = entityManager;\n\n        this.id = entityManager.createEntity();\n    }\n\n    add(componentType, initialValues = undefined)\n    {\n        this.entityManager.addComponent(this.id, componentType, initialValues);\n        return this;\n    }\n\n    remove(componentType)\n    {\n        this.entityManager.removeComponent(this.id, componentType);\n        return this;\n    }\n\n    has(...componentTypes)\n    {\n        return this.entityManager.hasComponent(this.id, ...componentTypes);\n    }\n\n    destroy()\n    {\n        this.entityManager.destroyEntity(this.id);\n    }\n\n    getEntityId() { return this.id; }\n}\n\nfunction create$1(entityManager)\n{\n    return new EntityWrapperBase(entityManager);\n}\n\nvar EntityWrapper = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    EntityWrapperBase: EntityWrapperBase,\n    create: create$1\n});\n\nconst FUNCTION_NAME = Symbol('functionName');\nconst FUNCTION_ARGS = Symbol('functionArguments');\n\nfunction resolveObject(target, path = [])\n{\n    let node = target;\n    for(let p of path)\n    {\n        if (typeof p === 'object' && FUNCTION_NAME in p)\n        {\n            node = node[p[FUNCTION_NAME]](...p[FUNCTION_ARGS]);\n        }\n        else\n        {\n            node = node[p];\n        }\n    }\n    return node;\n}\n\nfunction nextProperty(parentPath, nextKey)\n{\n    return [\n        ...parentPath,\n        nextKey,\n    ];\n}\n\nfunction nextFunction(parentPath, functionName, functionArguments = [])\n{\n    return [\n        ...parentPath,\n        {\n            [FUNCTION_NAME]: functionName,\n            [FUNCTION_ARGS]: functionArguments,\n        }\n    ];\n}\n\nclass DiffList extends Array\n{\n    static createRecord(type, key, value = undefined, path = [])\n    {\n        return {\n            type,\n            path,\n            key,\n            value,\n        };\n    }\n\n    addRecord(type, key, value = undefined, path = [])\n    {\n        let result = DiffList.createRecord(type, key, value, path);\n        this.push(result);\n        return result;\n    }\n\n    addRecords(records)\n    {\n        this.push(...records);\n    }\n}\n\nfunction applyDiff(source, sourceProp, diff)\n{\n    switch(diff.type)\n    {\n        case 'new':\n        case 'edit':\n            sourceProp[diff.key] = diff.value;\n            return true;\n        case 'delete':\n            delete sourceProp[diff.key];\n            return true;\n    }\n    return false;\n}\n\nfunction computeDiff(source, target, path = [], opts = {})\n{\n    let dst = new DiffList();\n    let sourceKeys = new Set(Object.getOwnPropertyNames(source));\n    for(let key of Object.getOwnPropertyNames(target))\n    {\n        if (!sourceKeys.has(key))\n        {\n            dst.addRecord('new', key, target[key], path);\n        }\n        else\n        {\n            sourceKeys.delete(key);\n            let result = computeDiff$4(source[key], target[key], nextProperty(path, key), opts);\n            if (!result)\n            {\n                dst.addRecord('edit', key, target[key], path);\n            }\n            else\n            {\n                dst.addRecords(result);\n            }\n        }\n    }\n    if (!opts.preserveSource)\n    {\n        for(let sourceKey of sourceKeys)\n        {\n            dst.addRecord('delete', sourceKey, undefined, path);\n        }\n    }\n    return dst;\n}\n\nfunction isType(arg)\n{\n    return Array.isArray(arg);\n}\n\nfunction applyDiff$1(source, sourceProp, diff)\n{\n    switch(diff.type)\n    {\n        case 'arrayObjectEdit':\n            sourceProp[diff.key] = diff.value;\n            return true;\n        case 'arrayObjectAppend':\n            ensureCapacity(diff.key);\n            sourceProp[diff.key] = diff.value;\n            return true;\n        case 'arrayObjectSplice':\n            sourceProp.splice(diff.key, diff.value);\n            return true;\n    }\n    return false;\n}\n\nfunction computeDiff$1(source, target, path = [], opts = {})\n{\n    let dst = new DiffList();\n    const length = Math.min(source.length, target.length);\n    for(let i = 0; i < length; ++i)\n    {\n        let result = computeDiff$4(source[i], target[i], nextProperty(path, i), opts);\n        if (!result)\n        {\n            dst.addRecord('arrayObjectEdit', i, target[i], path);\n        }\n        else\n        {\n            dst.addRecords(result);\n        }\n    }\n\n    if (!opts.preserveSource && source.length > target.length)\n    {\n        dst.addRecord('arrayObjectSplice', target.length, source.length - target.length, path);\n    }\n    else if (target.length > source.length)\n    {\n        for(let i = source.length; i < target.length; ++i)\n        {\n            dst.addRecord('arrayObjectAppend', i, target[i], path);\n        }\n    }\n    return dst;\n}\n\nfunction ensureCapacity(array, capacity)\n{\n    if (array.length < capacity)\n    {\n        array.length = capacity;\n    }\n}\n\nvar ArrayObjectDiff = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isType: isType,\n    applyDiff: applyDiff$1,\n    computeDiff: computeDiff$1\n});\n\nfunction isType$1(arg)\n{\n    return arg instanceof Set;\n}\n\nfunction applyDiff$2(source, sourceProp, diff)\n{\n    switch(diff.type)\n    {\n        case 'setAdd':\n            sourceProp.add(diff.key);\n            return true;\n        case 'setDelete':\n            sourceProp.delete(diff.key);\n            return true;\n    }\n    return false;\n}\n\n// NOTE: If the set's contents are objects, there is no way to \"update\" that object.\n// Therefore, this diff only works if NEW objects are added. This is the case for\n// any object with indexed with keys. Keys MUST be checked with '===' and CANNOT be diffed.\nfunction computeDiff$2(source, target, path = [], opts = {})\n{\n    let dst = new DiffList();\n    for(let value of target)\n    {\n        if (!source.has(value))\n        {\n            dst.addRecord('setAdd', value, undefined, path);\n        }\n    }\n    if (!opts.preserveSource)\n    {\n        for(let value of source)\n        {\n            if (!target.has(value))\n            {\n                dst.addRecord('setDelete', value, undefined, path);\n            }\n        }\n    }\n    return dst;\n}\n\nvar SetDiff = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isType: isType$1,\n    applyDiff: applyDiff$2,\n    computeDiff: computeDiff$2\n});\n\nfunction isType$2(arg)\n{\n    return arg instanceof Map;\n}\n\nfunction applyDiff$3(source, sourceProp, diff)\n{\n    switch(diff.type)\n    {\n        case 'mapNew':\n        case 'mapSet':\n            sourceProp.set(diff.key, diff.value);\n            return true;\n        case 'mapDelete':\n            sourceProp.delete(diff.key);\n            return true;\n    }\n    return false;\n}\n\n// NOTE: Same as set diffing, keys MUST be checked with '===' and CANNOT be diffed.\n// Although values can.\nfunction computeDiff$3(source, target, path = [], opts = {})\n{\n    let dst = new DiffList();\n    for(let [key, value] of target)\n    {\n        if (!source.has(key))\n        {\n            dst.addRecord('mapNew', key, value, path);\n        }\n        else\n        {\n            let result = computeDiff$4(source.get(key), value, nextFunction(path, 'get', [ key ]), opts);\n            if (!result)\n            {\n                dst.addRecord('mapSet', key, value, path);\n            }\n            else\n            {\n                dst.addRecords(result);\n            }\n        }\n    }\n    if (!opts.preserveSource)\n    {\n        for(let key of source.keys())\n        {\n            if (!target.has(key))\n            {\n                dst.addRecord('mapDelete', key, undefined, path);\n            }\n        }\n    }\n    return dst;\n}\n\nvar MapDiff = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isType: isType$2,\n    applyDiff: applyDiff$3,\n    computeDiff: computeDiff$3\n});\n\nconst DEFAULT_HANDLERS = [\n    ArrayObjectDiff,\n    MapDiff,\n    SetDiff,\n];\n\nconst DEFAULT_OPTS = {\n    handlers: DEFAULT_HANDLERS,\n    preserveSource: true,\n    maxDepth: 1000,\n};\n\nfunction computeDiff$4(source, target, path = [], opts = DEFAULT_OPTS)\n{\n    // Force replacement since we have reached maximum depth...\n    if (path.length >= opts.maxDepth) return null;\n    // Check if type at least matches...\n    if (typeof source !== typeof target) return null;\n    // If it's an object...(which there are many kinds)...\n    if (typeof source === 'object')\n    {\n        for(let handler of opts.handlers)\n        {\n            let type = handler.isType(source);\n            if (type ^ (handler.isType(target))) return null;\n            if (type) return handler.computeDiff(source, target, path, opts);\n        }\n\n        // It's probably just a simple object...\n        return computeDiff(source, target, path, opts);\n    }\n    else\n    {\n        // Any other primitive types...\n        if (source === target) return [];\n        else return null;\n    }\n}\n\nfunction applyDiff$4(source, diffList, opts = DEFAULT_OPTS)\n{\n    let sourceProp = source;\n    for(let diff of diffList)\n    {\n        // Find property...\n        sourceProp = resolveObject(source, diff.path);\n\n        // Apply property diff...\n        let flag = false;\n        for(let handler of opts.handlers)\n        {\n            flag = handler.applyDiff(source, sourceProp, diff);\n            if (flag) break;\n        }\n\n        // Apply default property diff...\n        if (!flag)\n        {\n            applyDiff(source, sourceProp, diff);\n        }\n    }\n    return source;\n}\n\n/**\n * Performs a fine diff on the entities and reconciles any changes with the current world state.\n * It respects the current world state with higher precedence over the modified changes. In other\n * words, any properties modified by the running program will be preserved. Only properties that\n * have not changed will be modified to reflect the new changes.\n * \n * This assumes entity constructors are deterministic, non-reflexive, and repeatable in a blank\n * test world.\n * \n * @param {HotEntityModule} prevHotEntityModule The old source hot entity module instance.\n * @param {HotEntityModule} nextHotEntityModule The new target hot entity module instance.\n * @param {Object} [opts] Any additional options.\n * @param {Function} [opts.worldObjectWrapper] If defined, the function will allow you wrap the create EntityManager\n * and specify the shape of the \"world\" parameter given to the entity constructors. The function takes in an instance\n * of EntityManager and returns an object to pass to the constructors.\n */\nfunction FineDiffStrategy(prevHotEntityModule, nextHotEntityModule, opts = undefined)\n{\n    const prevEntityConstructor = prevHotEntityModule.entityConstructor;\n    const prevEntityManagers = prevHotEntityModule.entityManagers;\n    const nextEntityConstructor = nextHotEntityModule.entityConstructor;\n    const nextEntityManagers = nextHotEntityModule.entityManagers;\n\n    let cacheEntityManager = new EntityManager();\n    let cacheWorld = (opts && opts.worldObjectWrapper)\n        ? opts.worldObjectWrapper(cacheEntityManager)\n        : cacheEntityManager;\n    let oldEntity = prevEntityConstructor(cacheWorld);\n    let newEntity = nextEntityConstructor(cacheWorld);\n\n    // Diff the old and new components...only update what has changed...\n    let componentValues = new Map();\n    for(let componentType of cacheEntityManager.getComponentTypesByEntityId(newEntity))\n    {\n        let newComponent = cacheEntityManager.getComponent(newEntity, componentType);\n        let oldComponent = cacheEntityManager.getComponent(oldEntity, componentType);\n\n        if (!oldComponent)\n        {\n            // ...it's an addition!\n            componentValues.set(componentType, true);\n        }\n        else\n        {\n            // ...it's an update!\n            let result = computeDiff$4(oldComponent, newComponent);\n            componentValues.set(componentType, result);\n        }\n    }\n    for(let componentType of cacheEntityManager.getComponentTypesByEntityId(oldEntity))\n    {\n        if (!componentValues.has(componentType))\n        {\n            // ...it's a deletion!\n            componentValues.set(componentType, false);\n        }\n    }\n\n    // Clean up cache entity manager...\n    cacheEntityManager.clear();\n\n    // Update all existing entity managers to the new entities...\n    for(let entityManager of prevEntityManagers)\n    {\n        // Update entities...\n        for(let entity of prevHotEntityModule.entities.get(entityManager).values())\n        {\n            for(let [componentType, values] of componentValues.entries())\n            {\n                if (typeof values === 'boolean')\n                {\n                    if (values)\n                    {\n                        // Addition!\n                        entityManager.addComponent(entity, componentType);\n                    }\n                    else\n                    {\n                        // Deletion!\n                        entityManager.removeComponent(entity, componentType);\n                    }\n                }\n                else\n                {\n                    // Update!\n                    let component = entityManager.getComponent(entity, componentType);\n                    applyDiff$4(component, values);\n                }\n            }\n        }\n    }\n}\n\nclass HotEntityModule\n{\n    constructor(entityModule, entityConstructor)\n    {\n        this.moduleId = entityModule.id;\n        this.entityConstructor = entityConstructor;\n\n        this.entities = new Map();\n    }\n\n    addEntity(entityManager, entityId)\n    {\n        if (this.entities.has(entityManager))\n        {\n            this.entities.get(entityManager).add(entityId);\n        }\n        else\n        {\n            let entitySet = new Set();\n            entitySet.add(entityId);\n            this.entities.set(entityManager, entitySet);\n        }\n\n        // Add listener...\n        entityManager.entityHandler.addEntityListener(\n            entityId,\n            'destroy',\n            this.removeEntity.bind(this, entityManager, entityId),\n            { handle: `${this.moduleId}:${entityId}` }\n        );\n    }\n\n    removeEntity(entityManager, entityId)\n    {\n        // Remove listener...(just in case this was not triggered by a destroy event)...\n        entityManager.entityHandler.removeEntityListener(\n            entityId,\n            'destroy',\n            `${this.moduleId}:${entityId}`);\n        \n        let entitySet = this.entities.get(entityManager);\n        entitySet.delete(entityId);\n        if (entitySet.size <= 0) this.entities.delete(entityManager);\n    }\n\n    /**\n     * Replaces the current state of with the next one. This includes all entities and entity managers.\n     * However, it assumes both hot entity replacements are for the same module.\n     * \n     * @param {HotEntityModule} nextHotEntityModule The new hot entity module object to replace this with.\n     * @param {Object} [opts] Any additional options.\n     * @param {Function} [opts.replaceStrategy] If defined, replacement will be handled by the passed in\n     * function. It takes 3 arguemtns: the hot entity replacement instance, the target instance, and the replaceOpts if defined.\n     * @param {Object} [opts.replaceOpts] This is given to the replacement strategy function, if defined.\n     */\n    replaceWith(nextHotEntityModule, opts = undefined)\n    {\n        // NOTE: Assumes more than one instance can exist at the same time.\n        // NOTE: Assumes components do not store self references (nor their own entity id).\n        // NOTE: Assumes you don't use objects in sets (unless they are immutable)...cause those are evil.\n\n        const replaceStrategy = (opts && opts.replaceStrategy) || FineDiffStrategy;\n        replaceStrategy.call(\n            undefined,\n            this,\n            nextHotEntityModule,\n            opts && opts.replaceOpts,\n        );\n\n        // Copy the new constructor over...\n        this.entityConstructor = nextHotEntityModule.entityConstructor;\n\n        // Copy any new entities over...\n        for(let entityManager of nextHotEntityModule.entityManagers)\n        {\n            for(let entity of nextHotEntityModule.entities.get(entityManager).values())\n            {\n                nextHotEntityModule.removeEntity(entityManager, entity);\n                this.addEntity(entityManager, entity);\n            }\n        }\n    }\n\n    isEmpty()\n    {\n        return this.entities.size <= 0;\n    }\n\n    get entityManagers()\n    {\n        return this.entities.keys();\n    }\n}\n\nconst HOT_ENTITY_MODULES = new Map();\n\nfunction enableForEntity(entityModule, entityManager, entityId)\n{\n    if (!HOT_ENTITY_MODULES.has(entityModule.id))\n    {\n        throw new Error('Module must be accepted first for HER to enable hot entity replacement.');\n    }\n\n    let hotEntityModule = HOT_ENTITY_MODULES.get(entityModule.id);\n    hotEntityModule.addEntity(entityManager, entityId);\n    return entityId;\n}\n\nfunction acceptForModule(entityModule, entityConstructor, worldConstructor = undefined)\n{\n    let newHotEntityModule = new HotEntityModule(entityModule, entityConstructor);\n    if (HOT_ENTITY_MODULES.has(entityModule.id))\n    {\n        console.log(`Reloading '${entityModule.id}'...`);\n        let oldHotEntityModule = HOT_ENTITY_MODULES.get(entityModule.id);\n        oldHotEntityModule.replaceWith(newHotEntityModule, worldConstructor);\n    }\n    else\n    {\n        console.log(`Preparing '${entityModule.id}'...`);\n        HOT_ENTITY_MODULES.set(entityModule.id, newHotEntityModule);\n    }\n\n    return entityModule;\n}\n\nfunction getInstanceForModuleId(entityModuleId)\n{\n    return HER_MODULES.get(entityModuleId);\n}\n\nvar HotEntityReplacement = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    enableForEntity: enableForEntity,\n    acceptForModule: acceptForModule,\n    getInstanceForModuleId: getInstanceForModuleId\n});\n\nconst NO_TRANSITION = {};\n\nclass SceneManager\n{\n    constructor()\n    {\n        this.registry = new Map();\n        this.sharedContext = {};\n\n        this._scene = null;\n        this._nextScene = null;\n        this._nextLoadOpts = null;\n        this._nextTransition = null;\n    }\n\n    /** Shared contexts are persistent across scenes of this manager. */\n    setSharedContext(context)\n    {\n        this.sharedContext = context;\n        return this;\n    }\n\n    register(name, scene)\n    {\n        if (typeof name !== 'string')\n        {\n            throw new Error('Scene name must be a string.');\n        }\n\n        this.registry.set(name, scene);\n        return this;\n    }\n\n    unregister(name)\n    {\n        this.registry.delete(name);\n        return this;\n    }\n\n    nextScene(scene, transition = null, loadOpts = {})\n    {\n        if (this._nextScene)\n        {\n            throw new Error('Cannot change scenes during a scene transition.');\n        }\n\n        // Whether to check the registry for the associated scene\n        if (typeof scene === 'string')\n        {\n            if (!this.registry.has(scene))\n            {\n                throw new Error(`Cannot find scene with name '${scene}'.`);\n            }\n\n            scene = this.registry.get(scene);\n        }\n\n        // For class-like scene structure\n        if (typeof scene === 'function')\n        {\n            scene = new scene();\n        }\n        // For object-like scene structure (includes modules)\n        else if (typeof scene === 'object')\n        {\n            // Whether the scene is non-extensible and should be converted to an object\n            if (!Object.isExtensible(scene))\n            {\n                scene = createExtensibleSceneFromModule(scene);\n            }\n        }\n        // For anything else...\n        else\n        {\n            throw new Error('Scene type not supported.');\n        }\n\n        this._nextScene = scene;\n        this._nextLoadOpts = loadOpts;\n\n        // NOTE: Transition MUST NEVER be null while switching scenes as it\n        // also serves as the flag to stop scene updates.\n        this._nextTransition = transition || NO_TRANSITION;\n    }\n\n    update(dt)\n    {\n        if (this._transition)\n        {\n            // TODO: Transitions should have their own methods and not just be tiny scenes...\n            \n            // Waiting for scene load...\n            this._updateStep(dt, this._transition);\n        }\n        else if (this._nextScene)\n        {\n            // Starting next scene request...\n            const nextScene = this._nextScene;\n            const nextLoadOpts = this._nextLoadOpts;\n            const nextTransition = this._nextTransition;\n\n            this._nextScene = null;\n            this._nextLoadOpts = null;\n            this._nextTransition = null;\n\n            this._transition = nextTransition;\n\n            let result = Promise.resolve();\n            let currentScene = this._scene;\n            if (currentScene)\n            {\n                if ('onStop' in currentScene) currentScene.onStop(this.sharedContext);\n                if ('unload' in currentScene) result = result.then(() =>\n                    currentScene.unload(this.sharedContext));\n            }\n\n            if ('load' in nextScene) result = result.then(() =>\n                nextScene.load(this.sharedContext, nextLoadOpts));\n            \n            result = result.then(() => {\n                this._scene = nextScene;\n                this._transition = null;\n\n                if ('onStart' in this._scene) this._scene.onStart(this.sharedContext);\n            });\n        }\n        else if (this._scene)\n        {\n            this._updateStep(dt, this._scene);\n        }\n    }\n\n    _updateStep(dt, target)\n    {\n        if ('onPreUpdate' in target) target.onPreUpdate(dt);\n        this.emit('preupdate', dt);\n        if ('onUpdate' in target) target.onUpdate(dt);\n        this.emit('update', dt);\n        if ('onPostUpdate' in target) target.onPostUpdate(dt);\n        this.emit('postupdate', dt);\n    }\n\n    getCurrentScene() { return this._scene; }\n    getNextScene() { return this._nextScene; }\n\n    [Symbol.iterator]()\n    {\n        return this.registry[Symbol.iterator]();\n    }\n}\nmixin(SceneManager);\n\nfunction createExtensibleSceneFromModule(sceneModule)\n{\n    return {\n        ...sceneModule\n    };\n}\n\n/**\n * This is not required to create a scene. Any object or class\n * with any of the defined functions can be considered a valid\n * scene. This is for ease of use and readability.\n */\nclass SceneBase\n{\n    /** @abstract */\n    async load(world, opts) {}\n    /** @abstract */\n    async unload(world) {}\n\n    /** @abstract */\n    onStart(world) {}\n    /** @abstract */\n    onStop(world) {}\n\n    /** @abstract */\n    onPreUpdate(dt) {}\n    /** @abstract */\n    onUpdate(dt) {}\n    /** @abstract */\n    onPostUpdate(dt) {}\n}\n\n/**\n * @module Utils\n * @version 1.0.2\n * \n * # Changelog\n * ## 1.0.2\n * - Added outline parameter for drawBox()\n * - Added uuid()\n */\n\nfunction randomHexColor()\n{\n    return '#' + Math.floor(Math.random() * 16777215).toString(16);\n}\n\nfunction loadImage(url)\n{\n    let image = new Image();\n    image.src = url;\n    return image;\n}\n\nfunction clampRange(value, min, max)\n{\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n}\n\nfunction clearScreen(ctx, width, height)\n{\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, width, height);\n}\n\nfunction drawText(ctx, text, x, y, radians = 0, fontSize = 16, color = 'white')\n{\n    ctx.translate(x, y);\n    if (radians) ctx.rotate(radians);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.font = `${fontSize}px sans-serif`;\n    ctx.fillStyle = color;\n    ctx.fillText(text, 0, 0);\n    if (radians) ctx.rotate(-radians);\n    ctx.translate(-x, -y);\n}\n\nfunction drawBox(ctx, x, y, radians = 0, w = 16, h = w, color = 'white', outline = false)\n{\n    ctx.translate(x, y);\n    if (radians) ctx.rotate(radians);\n    if (!outline)\n    {\n        ctx.fillStyle = color;\n        ctx.fillRect(-w / 2, -h / 2, w, h);\n    }\n    else\n    {\n        ctx.strokeStyle = color;\n        ctx.strokeRect(-w / 2, -h / 2, w, h);\n    }\n    if (radians) ctx.rotate(-radians);\n    ctx.translate(-x, -y);\n}\n\nfunction intersectBox(a, b)\n{\n    return (Math.abs(a.x - b.x) * 2 < (a.width + b.width)) &&\n        (Math.abs(a.y - b.y) * 2 < (a.height + b.height));\n}\n\nfunction applyMotion(entity, inverseFrictionX = 1, inverseFrictionY = inverseFrictionX)\n{\n    if (inverseFrictionX !== 1)\n    {\n        entity.dx *= inverseFrictionX;\n    }\n    if (inverseFrictionY !== 1)\n    {\n        entity.dy *= inverseFrictionY;\n    }\n    \n    entity.x += entity.dx;\n    entity.y += entity.dy;\n}\n\nfunction withinRadius(from, to, radius)\n{\n    const dx = from.x - to.x;\n    const dy = from.y - to.y;\n    return dx * dx + dy * dy <= radius * radius\n}\n\nfunction onDOMLoaded(listener)\n{\n    window.addEventListener('DOMContentLoaded', listener);\n}\n\nfunction lerp(a, b, dt)\n{\n    return a + (b - a) * dt;\n}\n\nfunction distance2D(from, to)\n{\n    let dx = to.x - from.x;\n    let dy = to.y - from.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction direction2D(from, to)\n{\n    let dx = to.x - from.x;\n    let dy = to.y - from.y;\n    return Math.atan2(dy, dx);\n}\n\nfunction lookAt2D(radians, target, dt)\n{\n    let step = cycleRange(target - radians, -Math.PI, Math.PI);\n    return clampRange(radians + step, radians - dt, radians + dt);\n}\n\nfunction cycleRange(value, min, max)\n{\n    let range = max - min;\n    let result = (value - min) % range;\n    if (result < 0) result += range;\n    return result + min;\n}\n\nfunction drawCircle(ctx, x, y, radius = 16, color = 'white', outline = false)\n{\n    ctx.fillStyle = color;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    if (outline) ctx.stroke();\n    else ctx.fill();\n}\n\n/**\n * Generates a uuid v4.\n * \n * @param {number} a The placeholder (serves for recursion within function).\n * @returns {string} The universally unique id.\n */\nfunction uuid(a = undefined)\n{\n    // https://gist.github.com/jed/982883\n    return a?(a^Math.random()*16>>a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,uuid);\n}\n\nvar Utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    randomHexColor: randomHexColor,\n    loadImage: loadImage,\n    clampRange: clampRange,\n    clearScreen: clearScreen,\n    drawText: drawText,\n    drawBox: drawBox,\n    intersectBox: intersectBox,\n    applyMotion: applyMotion,\n    withinRadius: withinRadius,\n    onDOMLoaded: onDOMLoaded,\n    lerp: lerp,\n    distance2D: distance2D,\n    direction2D: direction2D,\n    lookAt2D: lookAt2D,\n    cycleRange: cycleRange,\n    drawCircle: drawCircle,\n    uuid: uuid\n});\n\n/**\n * @module Display\n * @version 1.0.1\n */\n\nvar canvas;\nvar context;\n\n// Default setup...\nonDOMLoaded(() => {\n    if (!canvas)\n    {\n        let canvasElement = null;\n        let canvasContext = null;\n\n        // Try resolve to <display-port> if exists...\n        let displayElement = document.querySelector('display-port');\n        if (displayElement)\n        {\n            canvasElement = displayElement.getCanvas();\n            canvasContext = displayElement.getContext();\n        }\n        // Otherwise, find a <canvas> element...\n        else\n        {\n            canvasElement = document.querySelector('canvas');\n        }\n\n        if (canvasElement)\n        {\n            if (!canvasContext) canvasContext = canvasElement.getContext('2d');\n            attachCanvas(canvasElement, canvasContext);\n        }\n    }\n});\n\nfunction createCanvas(width = 320, height = width, parentElement = document.body)\n{\n    const canvasElement = document.createElement('canvas');\n    parentElement.appendChild(canvasElement);\n    attachCanvas(canvasElement, width, height);\n}\n\nfunction attachCanvas(canvasElement, canvasContext, width = 320, height = width)\n{\n    canvas = canvasElement;\n    context = canvasContext;\n    canvas.width = width;\n    canvas.height = height;\n}\n\nfunction drawBufferToScreen(ctx, viewportOffsetX = 0, viewportOffsetY = 0, viewportWidth = getClientWidth(), viewportHeight = getClientHeight())\n{\n    getDrawContext().drawImage(ctx.canvas, viewportOffsetX, viewportOffsetY, viewportWidth, viewportHeight);\n}\n\nfunction getCanvas()\n{\n    return canvas;\n}\n\nfunction getDrawContext()\n{\n    return context;\n}\n\nfunction getClientWidth()\n{\n    return canvas.clientWidth;\n}\n\nfunction getClientHeight()\n{\n    return canvas.clientHeight;\n}\n\nfunction getClientOffsetX()\n{\n    return canvas.offsetLeft;\n}\n\nfunction getClientOffsetY()\n{\n    return canvas.offsetTop;\n}\n\nvar Display = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createCanvas: createCanvas,\n    attachCanvas: attachCanvas,\n    drawBufferToScreen: drawBufferToScreen,\n    getCanvas: getCanvas,\n    getDrawContext: getDrawContext,\n    getClientWidth: getClientWidth,\n    getClientHeight: getClientHeight,\n    getClientOffsetX: getClientOffsetX,\n    getClientOffsetY: getClientOffsetY\n});\n\nvar audioContext = new AudioContext();\n\nfunction createSound(filepath, loop = false)\n{\n    const result = {\n        _playing: false,\n        _data: null,\n        _source: null,\n        play()\n        {\n            if (!this._data) return;\n            if (this._source) this.destroy();\n\n            let source = audioContext.createBufferSource();\n            source.loop = loop;\n            source.buffer = this._data;\n            source.addEventListener('ended', () => {\n                this._playing = false;\n            });\n            source.connect(audioContext.destination);\n            source.start(0);\n\n            this._source = source;\n            this._playing = true;\n        },\n        pause()\n        {\n            this._source.stop();\n            this._playing = false;\n        },\n        destroy()\n        {\n            if (this._source) this._source.disconnect();\n            this._source = null;\n        },\n        isPaused()\n        {\n            return !this._playing;\n        }\n    };\n\n    fetch(filepath)\n        .then(response => response.arrayBuffer())\n        .then(buffer => audioContext.decodeAudioData(buffer))\n        .then(data => result._data = data);\n\n    return result;\n}\n\nvar Audio = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createSound: createSound\n});\n\n/**\n * @module Input\n * @version 1.0.1\n */\n\nvar source = createSource();\nvar context$1 = createContext().attach(source);\n\n// Default setup...\nonDOMLoaded(() => {\n    if (!source.element)\n    {\n        let canvasElement = null;\n\n        // Try resolve to <display-port> if exists...\n        let displayElement = document.querySelector('display-port');\n        if (displayElement)\n        {\n            canvasElement = displayElement.getCanvas();\n        }\n        // Otherwise, find a <canvas> element...\n        else\n        {\n            canvasElement = document.querySelector('canvas');\n        }\n\n        if (canvasElement)\n        {\n            attachCanvas$1(canvasElement);\n        }\n    }\n});\n\nfunction attachCanvas$1(canvasElement)\n{\n    if (source.element) source.detach();\n    return source.attach(canvasElement);\n}\n\nfunction createContext$1(priority = 0, active = true)\n{\n    return createContext().setPriority(priority).toggle(active).attach(source);\n}\n\nfunction createInput(adapter)\n{\n    return context$1.registerInput(getNextInputName(), adapter);\n}\n\nfunction createAction(...eventKeyStrings)\n{\n    return context$1.registerAction(getNextInputName(), ...eventKeyStrings);\n}\n\nfunction createRange(eventKeyString)\n{\n    return context$1.registerRange(getNextInputName(), eventKeyString);\n}\n\nfunction createState(eventKeyMap)\n{\n    return context$1.registerState(getNextInputName(), eventKeyMap);\n}\n\nfunction poll()\n{\n    return source.poll();\n}\n\nfunction handleEvent(eventKeyString, value)\n{\n    return source.handleEvent(eventKeyString, value);\n}\n\nvar nextInputNameId = 1;\nfunction getNextInputName()\n{\n    return `__input#${nextInputNameId++}`;\n}\n\nvar Input = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    attachCanvas: attachCanvas$1,\n    createContext: createContext$1,\n    createInput: createInput,\n    createAction: createAction,\n    createRange: createRange,\n    createState: createState,\n    poll: poll,\n    handleEvent: handleEvent\n});\n\nconst DEFAULT_RNG = new RandomGenerator();\n\nfunction createRandom(seed = 0)\n{\n    return new SimpleRandomGenerator(seed);\n}\n\nfunction random()\n{\n    return DEFAULT_RNG.random();\n}\n\nfunction randomRange(min, max)\n{\n    return DEFAULT_RNG.randomRange(min, max);\n}\n\nfunction randomChoose(choices)\n{\n    return DEFAULT_RNG.randomChoose(choices);\n}\n\nfunction randomSign()\n{\n    return DEFAULT_RNG.randomSign();\n}\n\nvar Random = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createRandom: createRandom,\n    random: random,\n    randomRange: randomRange,\n    randomChoose: randomChoose,\n    randomSign: randomSign\n});\n\nconst GAME_LOOPS = new Map();\n\n/**\n * Starts a game loop. This is not required to start a loop, but is\n * here for ease of use.\n * \n * @example\n * let context = {\n *   start() {\n *     // Start code here...\n *   },\n *   update(dt) {\n *     // Update code here...\n *   }\n * };\n * GameLoop.start(context);\n * \n * @example\n * GameLoop.start()\n *   .on('start', function start() {\n *     // Start code here...\n *   })\n *   .on('update', function update(dt) {\n *     // Update code here...\n *   });\n * \n * @example\n * let gameLoop = new GameLoop();\n * gameLoop\n *   .on('start', ...)\n *   .on('update', ...)\n *   .on('stop', ...);\n * \n * @param {Object} [handle] The handle that refers to the registered game\n * loop. If the handle has not been previously registered, it will\n * register the handle with a new game loop, with the handle serving as\n * both the new game loop's handle and context (only if the handle is\n * an object, otherwise, it will create an empty context).\n * \n * @returns {GameLoop} The started game loop instance.\n */\nfunction start(handle = undefined)\n{\n    let result;\n    if (GAME_LOOPS.has(handle))\n    {\n        throw new Error('Cannot start game loop with duplicate handle.');\n    }\n    else\n    {\n        let context;\n        if (typeof handle === 'object') context = handle;\n        else context = {};\n\n        result = new GameLoop(context);\n    }\n    GAME_LOOPS.set(handle, result);\n\n    // Start the loop (right after any chained method calls, like event listeners)\n    setTimeout(() => result.start(), 0);\n    return result;\n}\n\n/**\n * Stops a game loop. This is not required to stop a loop, but is\n * here for ease of use.\n */\nfunction stop(handle)\n{\n    if (GAME_LOOPS.has(handle))\n    {\n        let gameLoop = GAME_LOOPS.get(handle);\n        gameLoop.stop();\n        GAME_LOOPS.delete(handle);\n        return gameLoop;\n    }\n\n    return null;\n}\n\nfunction createGameLoop(context = {})\n{\n    return new GameLoop(context);\n}\n\nvar Game = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    start: start,\n    stop: stop,\n    createGameLoop: createGameLoop\n});\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (self);\n\n\n\n//# sourceURL=webpack:///./lib/milque.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./src/Player.js":
/*!***********************!*\
  !*** ./src/Player.js ***!
  \***********************/
/*! exports provided: create */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony import */ var _lib_milque_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/milque.js */ \"./lib/milque.js\");\n/* harmony import */ var _Transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transform.js */ \"./src/Transform.js\");\n/* harmony import */ var _ShapeRenderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShapeRenderer.js */ \"./src/ShapeRenderer.js\");\n/* harmony import */ var _RainbowColor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RainbowColor.js */ \"./src/RainbowColor.js\");\n\n\n\n\n\nfunction create(world)\n{\n    let result = _lib_milque_js__WEBPACK_IMPORTED_MODULE_0__[\"EntityWrapper\"].create(world.entities)\n        .add(_Transform_js__WEBPACK_IMPORTED_MODULE_1__[\"Transform\"], { x: 16, y: 16 })\n        .add(_ShapeRenderer_js__WEBPACK_IMPORTED_MODULE_2__[\"ShapeRenderer\"], { shape: 'box', radius: 32 })\n        .add(_RainbowColor_js__WEBPACK_IMPORTED_MODULE_3__[\"RainbowColor\"], { text: 'woot?' })\n        .getEntityId();\n    return _lib_milque_js__WEBPACK_IMPORTED_MODULE_0__[\"HotEntityReplacement\"].enableForEntity(module, world.entities, result);\n}\n\nif (false)\n{}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./src/Player.js?");

/***/ }),

/***/ "./src/RainbowColor.js":
/*!*****************************!*\
  !*** ./src/RainbowColor.js ***!
  \*****************************/
/*! exports provided: RainbowColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RainbowColor\", function() { return RainbowColor; });\nfunction RainbowColor()\n{\n    this.color = 'white';\n    this.colors = ['red', 'orange', 'yellow', 'lime', 'blue', 'violet'];\n    this.text = 'Hooray!';\n}\n\n\n//# sourceURL=webpack:///./src/RainbowColor.js?");

/***/ }),

/***/ "./src/ShapeRenderer.js":
/*!******************************!*\
  !*** ./src/ShapeRenderer.js ***!
  \******************************/
/*! exports provided: ShapeRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeRenderer\", function() { return ShapeRenderer; });\nfunction ShapeRenderer()\n{\n    this.shape = 'box';\n    this.radius = 16;\n}\n\n\n//# sourceURL=webpack:///./src/ShapeRenderer.js?");

/***/ }),

/***/ "./src/Transform.js":
/*!**************************!*\
  !*** ./src/Transform.js ***!
  \**************************/
/*! exports provided: Transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Transform\", function() { return Transform; });\nfunction Transform()\n{\n    this.x = 0;\n    this.y = 0;\n}\n\n\n//# sourceURL=webpack:///./src/Transform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_milque_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/milque.js */ \"./lib/milque.js\");\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Player.js */ \"./src/Player.js\");\n/* harmony import */ var _RainbowColor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RainbowColor.js */ \"./src/RainbowColor.js\");\n\n\n\n\n\nvar world = {\n    entities: new _lib_milque_js__WEBPACK_IMPORTED_MODULE_0__[\"EntityManager\"](),\n};\n\nlet button = document.createElement('button');\nbutton.innerHTML = 'Boo.';\nbutton.onclick = onClick;\ndocument.body.appendChild(button);\n\nlet player = _Player_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"](world);\n\nfunction onClick(e)\n{\n    let component = world.entities.getComponent(player, _RainbowColor_js__WEBPACK_IMPORTED_MODULE_2__[\"RainbowColor\"]);\n    component.colors = [];\n}\n\nfunction main(now)\n{\n    requestAnimationFrame(main);\n\n    let component = world.entities.getComponent(player, _RainbowColor_js__WEBPACK_IMPORTED_MODULE_2__[\"RainbowColor\"]);\n    button.style.color = component.color;\n    button.textContent = component.text;\n    if (Math.random() > 0.9)\n    {\n        let other = component.colors.shift();\n        component.colors.push(component.color);\n        component.color = other;\n    }\n}\n\nmain(performance.now());\n\nif (false)\n{}\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });